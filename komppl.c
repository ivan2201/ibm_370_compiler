/*
***** Н А Ч А Л О   файла компилятора с языка высокого уровня
*/

/*
***** Б л о к  об'явлений макроопределений
*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
						  /* п р е д е л ь н ы е    */
						  /* размеры:               */
#define MAXNISXTXT 50                             /* - исходного текста;    */
#define NSINT     350                             /* - табл.синтакс.правил; */
#define NCEL       20                             /* - стека целей;         */
#define NDST      500                             /* - стека достижений;    */
#define NVXOD      52                             /* - табл.входов;         */
#define NSTROKA   500                             /* - строки плотн.текста; */
#define NNETRM     16                             /* - списка нетерминалов; */
#define MAXLTXT    50                             /* - выходного текста;    */
#define MAXFORMT   30                             /* - форматированного ин- */
						  /* терпретируемого  фраг- */
						  /* мента исх.текста;      */
#define NSYM      100                             /* - таблицы имен и меток */

#define UTF8                                      /* - указываем что в системе utf-8 
																											 для перерассчёта длины комментариев */
																											 
#define __DEBUG_SINT                               /* - включаем вывод отладки синт. анализатора */
																											 
#define _DEBUG_LEX                                /* - включаем вывод лексич. анализатора */

typedef unsigned char uc;

/*
***** Б а з а  данных компилятора
*/

/*
***** Б л о к  об'явления массива с исходным текстом
*/

int  NISXTXT;                                     /* длина массива          */
char ISXTXT[MAXNISXTXT][80];                      /* тело массива           */

/*
***** Б л о к  об'явления рабочих переменных
*/

int I1,I2,I3,I4;                                  /* счетчики циклов        */

char PREDSYM = ' ';                               /*последний обработанный  */
						  /*символ в уплотненном    */
						  /*исходном тексте         */

char STROKA [ NSTROKA ];                          /*место хранения уплотнен-*/
						  /*ного исходного текста   */
						  
unsigned char * COMMENT;                                /* текущий комментарий */

int I,J,K,L;                                      /*текущие индексы соответ-*/
						  /*ственно в:              */
						  /* - уплотненном тексте;  */
						  /* - табл.грамм.правил;   */
						  /* - стеке поставленных   */
						  /*целей;                  */
						  /* - стеке достигнутых    */
						  /*целей;                  */

union                                             /*шаблон для генерации    */
 {                                                /*записи выходного файла  */
  char    BUFCARD [80];                           /*на АССЕМБЛЕРЕ IBM 370   */
  struct
   {
    char METKA   [8];
    char PROB1;
    char OPERAC  [5];
    char PROB2;
    char OPERAND [12];
    char PROB3;
    char COMM    [52];
   } _BUFCARD;
 } ASS_CARD ;


char ASSTXT [ MAXLTXT ][80];                      /*массив для хранения     */
						  /*выходного текста на     */
						  /*АССЕМБЛЕРЕ IBM 370      */

int  IASSTXT;                                     /*индекс выходного массива*/

char FORMT [MAXFORMT] [9];                        /*массив для форматирован-*/
						  /*ного  (в виде последова-*/
						  /*тельности 9-ти позицион-*/
						  /*ных строк-лексем) пред- */
						  /*ставления интерпретиру- */
						  /*емого фрагмента исходно-*/
						  /*го плотного текста      */

int  IFORMT;                                      /*индекс форматированного */
						  /*массива                 */
/*
***** Б л о к  об'явления таблиц базы данных
*/

/*
***** Т а б л и ц а, используемая как магазин (стек) достижений
*/

struct
 {
  char DST1 [ 4 ];
  int  DST2;
  int  DST3;
  int  DST4;
  int  DST5;
 } DST [ NDST ];

/*
***** Т а б л и ц а, используемая как магазин (стек) целей
*/

struct
 {
  char CEL1 [ 4 ];
  int  CEL2;
  int  CEL3;
 } CEL [ NCEL ];

/*
***** Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
***** сгруппированных в "кусты" и представленных в виде двухнапрвленного
***** списка с альтернативными разветвлениями
*/

struct
 {
  int  POSL;
  int  PRED;
  char DER[4];
  int  ALT;
 } SINT [ NSINT ] =
/*   __________ _________ _______ _______ ______
    |  NN      :    посл : пред  :  дер  : альт |
    |__________:_________:_______:_______:______|                          */
{
 {/*.    0     .*/    -1 ,    -1 , "***" ,   -1 },
  /*                                               вход с символа - 0      */
 {/*.    1     .*/     2 ,     0 , "0  " ,    0 },
 {/*.    2     .*/     3 ,     1 , "CIF" ,    0 },
 {/*.    3     .*/     0 ,     2 , "*  " ,    0 },
  /*                                               вход с символа - 1      */
 {/*.    4     .*/     5 ,     0 , "1  " ,    0 },
 {/*.    5     .*/     6 ,     4 , "CIF" ,    7 },
 {/*.    6     .*/     0 ,     5 , "*  " ,    0 },

 {/*.    7     .*/     8 ,     4 , "MAN" ,    0 },
 {/*.    8     .*/     0 ,     7 , "*  " ,    0 },
  /*                                               вход с символа - 2      */
 {/*.    9     .*/    10 ,     0 , "2  " ,    0 },
 {/*.   10     .*/    11 ,     9 , "CIF" ,    0 },
 {/*.   11     .*/     0 ,    10 , "*  " ,    0 },
  /*                                               вход с символа - 3      */
 {/*.   12     .*/    13 ,     0 , "3  " ,    0 },
 {/*.   13     .*/    14 ,    12 , "CIF" ,    0 },
 {/*.   14     .*/     0 ,    13 , "*  " ,    0 },
  /*                                               вход с символа - 4      */
 {/*.   15     .*/    16 ,     0 , "4  " ,    0 },
 {/*.   16     .*/    17 ,    15 , "CIF" ,    0 },
 {/*.   17     .*/     0 ,    16 , "*  " ,    0 },
  /*                                               вход с символа - 5      */
 {/*.   18     .*/    19 ,     0 , "5  " ,    0 },
 {/*.   19     .*/    20 ,    18 , "CIF" ,    0 },
 {/*.   20     .*/     0 ,    19 , "*  " ,    0 },
  /*                                               вход с символа - 6      */
 {/*.   21     .*/    22 ,     0 , "6  " ,    0 },
 {/*.   22     .*/    23 ,    21 , "CIF" ,    0 },
 {/*.   23     .*/     0 ,    22 , "*  " ,    0 },
  /*                                               вход с символа - 7      */
 {/*.   24     .*/    25 ,     0 , "7  " ,    0 },
 {/*.   25     .*/    26 ,    24 , "CIF" ,    0 },
 {/*.   26     .*/     0 ,    25 , "*  " ,    0 },
  /*                                               вход с символа - 8      */
 {/*.   27     .*/    28 ,     0 , "8  " ,    0 },
 {/*.   28     .*/    29 ,    27 , "CIF" ,    0 },
 {/*.   29     .*/     0 ,    28 , "*  " ,    0 },
  /*                                               вход с символа - 9      */
 {/*.   30     .*/    31 ,     0 , "9  " ,    0 },
 {/*.   31     .*/    32 ,    30 , "CIF" ,    0 },
 {/*.   32     .*/     0 ,    31 , "*  " ,    0 },
  /*                                               вход с символа - A      */
 {/*.   33     .*/    34 ,     0 , "A  " ,    0 },
 {/*.   34     .*/    35 ,    33 , "BUK" ,    0 },
 {/*.   35     .*/     0 ,    34 , "*  " ,    0 },
  /*                                               вход с символа - B      */
 {/*.   36     .*/    37 ,     0 , "B  " ,    0 },
 {/*.   37     .*/    38 ,    36 , "BUK" ,    0 },
 {/*.   38     .*/     0 ,    37 , "*  " ,    0 },
  /*                                               вход с символа - C      */
 {/*.   39     .*/    40 ,     0 , "C  " ,    0 },
 {/*.   40     .*/    41 ,    39 , "BUK" ,    0 },
 {/*.   41     .*/     0 ,    40 , "*  " ,    0 },
  /*                                               вход с символа - D      */
 {/*.   42     .*/    43 ,     0 , "D  " ,    0 },
 {/*.   43     .*/    44 ,    42 , "BUK" ,   45 },
 {/*.   44     .*/     0 ,    43 , "*  " ,    0 },

 {/*.   45     .*/    46 ,    42 , "C  " ,    0 },
 {/*.   46     .*/    47 ,    45 , "L  " ,    0 },
 {/*.   47     .*/    48 ,    46 , "   " ,    0 },
 {/*.   48     .*/    49 ,    47 , "IPE" ,    0 },
 {/*.   49     .*/    50 ,    48 , "   " ,    0 },
 {/*.   50     .*/    51 ,    49 , "B  " ,  187 },
 {/*.   51     .*/    52 ,    50 , "I  " ,    0 },
 {/*.   52     .*/    53 ,    51 , "N  " ,    0 },
 {/*.   53     .*/    54 ,    52 , "   " ,    0 },
 {/*.   54     .*/    55 ,    53 , "F  " ,    0 },
 {/*.   55     .*/    56 ,    54 , "I  " ,    0 },
 {/*.   56     .*/    57 ,    55 , "X  " ,    0 },
 {/*.   57     .*/    58 ,    56 , "E  " ,    0 },
 {/*.   58     .*/    59 ,    57 , "D  " ,    0 },
 {/*.   59     .*/    60 ,    58 , "(  " ,  240 },
 {/*.   60     .*/    61 ,    59 , "RZR" ,    0 },
 {/*.   61     .*/    62 ,    60 , ")  " ,    0 },
 {/*.   62     .*/    63 ,    61 , ";  " ,   65 },
 {/*.   63     .*/    64 ,    62 , "ODC" ,    0 },
 {/*.   64     .*/     0 ,    63 , "*  " ,    0 },

 {/*.   65     .*/    66 ,    61 , "I  " ,    0 },
 {/*.   66     .*/    67 ,    65 , "N  " ,    0 },
 {/*.   67     .*/    68 ,    66 , "I  " ,    0 },
 {/*.   68     .*/    69 ,    67 , "T  " ,    0 },
 {/*.   69     .*/    70 ,    68 , "(  " ,    0 },
 {/*.   70     .*/    71 ,    69 , "LIT" ,  205 },
 {/*.   71     .*/    72 ,    70 , ")  " ,    0 },
 {/*.   72     .*/    73 ,    71 , ";  " ,    0 },
 {/*.   73     .*/   186 ,    72 , "ODC" ,    0 },
  /*                                               вход с символа - E      */
 {/*.   74     .*/    75 ,     0 , "E  " ,    0 },
 {/*.   75     .*/    76 ,    74 , "N  " ,   82 },
 {/*.   76     .*/    77 ,    75 , "D  " ,    0 },
 {/*.   77     .*/    78 ,    76 , "   " ,    0 },
 {/*.   78     .*/    79 ,    77 , "IPR" ,    0 },
 {/*.   79     .*/    80 ,    78 , ";  " ,    0 },
 {/*.   80     .*/    81 ,    79 , "OEN" ,    0 },
 {/*.   81     .*/     0 ,    80 , "*  " ,    0 },

 {/*.   82     .*/    83 ,    74 , "BUK" ,    0 },
 {/*.   83     .*/     0 ,    82 , "*  " ,    0 },
  /*                                               вход с символа - M      */
 {/*.   84     .*/    85 ,     0 , "M  " ,    0 },
 {/*.   85     .*/    86 ,    84 , "BUK" ,    0 },
 {/*.   86     .*/     0 ,    85 , "*  " ,    0 },
  /*                                               вход с символа - P      */
 {/*.   87     .*/    88 ,     0 , "P  " ,    0 },
 {/*.   88     .*/    89 ,    87 , "BUK" ,    0 },
 {/*.   89     .*/     0 ,    88 , "*  " ,    0 },
  /*                                               вход с символа - X      */
 {/*.   90     .*/    91 ,     0 , "X  " ,    0 },
 {/*.   91     .*/    92 ,    90 , "BUK" ,    0 },
 {/*.   92     .*/     0 ,    91 , "*  " ,    0 },
  /*                                               вход с символа - BUK    */
 {/*.   93     .*/    94 ,     0 , "BUK" ,    0 },
 {/*.   94     .*/    95 ,    93 , "IDE" ,    0 },
 {/*    95     .*/     0 ,    94 , "*  " ,    0 },
  /*                                               вход с символа - IDE    */
 {/*.   96     .*/    97 ,     0 , "IDE" ,    0 },
 {/*.   97     .*/    98 ,    96 , "BUK" ,  100 },
 {/*.   98     .*/    99 ,    97 , "IDE" ,    0 },
 {/*.   99     .*/     0 ,    98 , "*  " ,    0 },

 {/*.  100     .*/   101 ,    96 , "CIF" ,  103 },
 {/*.  101     .*/   102 ,   100 , "IDE" ,    0 },
 {/*.  102     .*/     0 ,   101 , "*  " ,    0 },

 {/*.  103     .*/   104 ,    96 , "IPE" ,  105 }, 
 {/*.  104     .*/     0 ,   103 , "*  " ,    0 },

 {/*.  105     .*/   106 ,    96 , "IPR" ,    0 }, 
 {/*.  106     .*/     0 ,   105 , "*  " ,    0 },
  /*                                               вход с символа - +      */
 {/*.  107     .*/   108 ,     0 , "+  " ,    0 },
 {/*.  108     .*/   109 ,   107 , "ZNK" ,    0 },
 {/*.  109     .*/     0 ,   108 , "*  " ,    0 },
  /*                                               вход с символа - -      */
 {/*.  110     .*/   111 ,     0 , "-  " ,    0 },
 {/*.  111     .*/   112 ,   110 , "ZNK" ,    0 },
 {/*.  112     .*/     0 ,   111 , "*  " ,    0 },
  /*                                               вход с символа - IPR    */
 {/*.  113     .*/   114 ,     0 , "IPR" ,    0 },
 {/*.  114     .*/   115 ,   113 , ":  " ,    0 },
 {/*.  115     .*/   116 ,   114 , "P  " ,    0 },
 {/*.  116     .*/   117 ,   115 , "R  " ,    0 },
 {/*.  117     .*/   118 ,   116 , "O  " ,    0 },
 {/*.  118     .*/   119 ,   117 , "C  " ,    0 },
 {/*.  119     .*/   120 ,   118 , "   " ,    0 },
 {/*.  120     .*/   121 ,   119 , "O  " ,    0 },
 {/*.  121     .*/   122 ,   120 , "P  " ,    0 },
 {/*.  122     .*/   123 ,   121 , "T  " ,    0 },
 {/*.  123     .*/   124 ,   122 , "I  " ,    0 },
 {/*.  124     .*/   125 ,   123 , "O  " ,    0 },
 {/*.  125     .*/   126 ,   124 , "N  " ,    0 },
 {/*.  126     .*/   127 ,   125 , "S  " ,    0 },
 {/*.  127     .*/   128 ,   126 , "(  " ,    0 },
 {/*.  128     .*/   129 ,   127 , "M  " ,    0 },
 {/*.  129     .*/   130 ,   128 , "A  " ,    0 },
 {/*.  130     .*/   131 ,   129 , "I  " ,    0 },
 {/*.  131     .*/   132 ,   130 , "N  " ,    0 },
 {/*.  132     .*/   133 ,   131 , ")  " ,    0 },
 {/*.  133     .*/   134 ,   132 , ";  " ,    0 },
 {/*.  134     .*/   135 ,   133 , "OPR" ,    0 },
 {/*.  135     .*/     0 ,   134 , "*  " ,    0 },
 /*                                                вход с символа - CIF    */
 {/*.  136     .*/   137 ,     0 , "CIF" ,    0 },
 {/*.  137     .*/   138 ,   136 , "RZR" ,    0 },
 {/*.  138     .*/     0 ,   137 , "*  " ,    0 },
  /*                                               вход с символа - RZR    */
 {/*.  139     .*/   140 ,     0 , "RZR" ,    0 },
 {/*.  140     .*/   141 ,   139 , "CIF" ,    0 },
 {/*.  141     .*/   142 ,   140 , "RZR" ,    0 },
 {/*.  142     .*/     0 ,   141 , "*  " ,    0 },
  /*                                               вход с символа - MAN    */
 {/*.  143     .*/   144 ,     0 , "MAN" ,    0 },
 {/*.  144     .*/   145 ,   143 , "B  " ,  147 },
 {/*.  145     .*/   146 ,   144 , "LIT" ,    0 },
 {/*.  146     .*/     0 ,   145 , "*  " ,    0 },

 {/*.  147     .*/   148 ,   143 , "0  " ,  150 },
 {/*.  148     .*/   149 ,   147 , "MAN" ,    0 },
 {/*.  149     .*/     0 ,   148 , "*  " ,    0 },

 {/*.  150     .*/   151 ,   143 , "1  " ,    0 },
 {/*.  151     .*/   152 ,   150 , "MAN" ,    0 },
 {/*.  152     .*/     0 ,   151 , "*  " ,    0 },
  /*                                               вход с символа - IPE    */
 {/*.  153     .*/   154 ,     0 , "IPE" ,    0 },
 {/*.  154     .*/   155 ,   153 , "AVI" ,  156 },
 {/*.  155     .*/   156 ,   154 , "*  " ,    0 },
 {/*.  156     .*/   157 ,   155 , "=  " ,    0 },
 {/*.  157     .*/   158 ,   156 , "AVI" ,    0 },
 {/*.  158     .*/   159 ,   157 , ";  " ,    0 },

 {/*.  159     .*/   160 ,   158 , "OPA" ,    0 },
 {/*.  160     .*/     0 ,   159 , "*  " ,    0 },
  /*                                               вход с символа - LIT    */
 {/*.  161     .*/   162 ,     0 , "LIT" ,    0 },
 {/*.  162     .*/   163 ,   161 , "AVI" ,    0 },
 {/*.  163     .*/     0 ,   162 , "*  " ,    0 },
  /*.                                              вход с символа - AVI    */
 {/*.  164     .*/   165 ,     0 , "AVI" ,    0 },
 {/*.  165     .*/   166 ,   164 , "ZNK" ,    0 },
 {/*.  166     .*/   167 ,   165 , "LIT" ,  168 },
 {/*.  167     .*/   197 ,   166 , "AVI" ,    0 },

 {/*.  168     .*/   169 ,   165 , "IPE" ,  277 },
 {/*.  169     .*/   170 ,   168 , "AVI" ,    0 },
 {/*.  170     .*/     0 ,   169 , "*  " ,    0 },
  /*                                               вход с символа - OPR    */
 {/*.  171     .*/   172 ,     0 , "OPR" ,    0 },
 {/*.  172     .*/   173 ,   171 , "TEL" ,    0 },
 {/*.  173     .*/   174 ,   172 , "OEN" ,    0 },
 {/*.  174     .*/   175 ,   173 , "PRO" ,    0 },
 {/*.  175     .*/     0 ,   174 , "*  " ,    0 },
  /*.                                              вход с символа - ODC    */
 {/*.  176     .*/   177 ,     0 , "ODC" ,    0 },
 {/*.  177     .*/   178 ,   176 , "TEL" ,    0 },
 {/*.  178     .*/     0 ,   177 , "*  " ,    0 },
  /*.                                              вход с символа - TEL    */
 {/*.  179     .*/   180 ,     0 , "TEL" ,    0 },
 {/*.  180     .*/   181 ,   179 , "ODC" ,  183 },
 {/*.  181     .*/   182 ,   180 , "TEL" ,    0 },
 {/*.  182     .*/     0 ,   181 , "*  " ,    0 },

 {/*.  183     .*/   184 ,   179 , "OPA" ,    0 },
 {/*.  184     .*/   185 ,   183 , "TEL" ,    0 },
 {/*.  185     .*/     0 ,   184 , "*  " ,    0 },

 {/*.  186     .*/     0 ,    73 , "*  " ,    0 },


 {/*.  187     .*/   188 ,    49 , "C  " ,  201 },
 {/*.  188     .*/   189 ,   187 , "H  " ,    0 },
 {/*.  189     .*/   190 ,   188 , "A  " ,    0 },
 {/*.  190     .*/   191 ,   189 , "R  " ,    0 },
 {/*.  191     .*/   192 ,   190 , "(  " ,    0 },
 {/*.  192     .*/   193 ,   191 , "RZR" ,    0 },
 {/*.  193     .*/   194 ,   192 , ")  " ,    0 },
 {/*.  194     .*/   195 ,   193 , ";  " ,    0 },
 {/*.  195     .*/   196 ,   194 , "ODC" ,    0 },
 {/*.  196     .*/     0 ,   195 , "*  " ,    0 },

 {/*.  197     .*/     0 ,   166 , "*  " ,    0 },
  /*                                               вход с символа - *      */
 {/*.  198     .*/   199 ,     0 , "*  " ,    0 },
 {/*.  199     .*/   200 ,   198 , "ZNK" ,    0 },
 {/*.  200     .*/     0 ,   199 , "*  " ,    0 },
 
 {/*.  201     .*/   202 ,    49 , "D  " ,    0 },
 {/*.  202     .*/   203 ,   201 , "E  " ,    0 },
 {/*.  203     .*/   204 ,   202 , "C  " ,    0 },
 {/*.  204     .*/   205 ,   203 , "   " ,    0 },
 {/*.  205     .*/   206 ,   204 , "F  " ,    0 },
 {/*.  206     .*/   207 ,   205 , "I  " ,    0 },
 {/*.  207     .*/   208 ,   206 , "X  " ,    0 },
 {/*.  208     .*/   209 ,   207 , "E  " ,    0 },
 {/*.  209     .*/   210 ,   208 , "D  " ,    0 },
 {/*.  210     .*/   211 ,   209 , "(  " ,  237 },
 {/*.  211     .*/   212 ,   210 , "RZR" ,    0 },
 {/*.  212     .*/   213 ,   211 , ")  " ,    0 },
 {/*.  213     .*/   214 ,   212 , ";  " ,  216 },
 {/*.  214     .*/   215 ,   213 , "ODC" ,    0 },
 {/*.  215     .*/   216 ,   214 , "*  " ,    0 },

 {/*.  216     .*/   217 ,   212 , "I  " ,    0 },
 {/*.  217     .*/   218 ,   217 , "N  " ,    0 },
 {/*.  218     .*/   219 ,   218 , "I  " ,    0 },
 {/*.  219     .*/   220 ,   219 , "T  " ,    0 },
 {/*.  220     .*/   221 ,   220 , "(  " ,    0 },
 {/*.  221     .*/   222 ,   221 , "RZR" ,    0 },
 {/*.  222     .*/   223 ,   222 , ")  " ,    0 },
 {/*.  223     .*/   224 ,   223 , ";  " ,    0 },
 {/*.  224     .*/   225 ,   224 , "ODC" ,    0 },
 {/*.  225     .*/     0 ,   225 , "*  " ,    0 },
 
 {/*.  226     .*/   227 ,   209 , "   " ,    0 },
 {/*.  227     .*/   228 ,   226 , "I  " ,    0 },
 {/*.  228     .*/   229 ,   227 , "N  " ,    0 },
 {/*.  229     .*/   230 ,   228 , "I  " ,    0 },
 {/*.  230     .*/   231 ,   229 , "T  " ,    0 },
 {/*.  231     .*/   232 ,   230 , "(  " ,    0 },
 {/*.  232     .*/   233 ,   231 , "LIT" ,  259 },
 {/*.  233     .*/   234 ,   232 , ")  " ,    0 },
 {/*.  234     .*/   235 ,   233 , ";  " ,    0 },
 {/*.  235     .*/   236 ,   234 , "ODC" ,    0 },
 {/*.  236     .*/     0 ,   235 , "*  " ,    0 },
 
 {/*.  237     .*/   238 ,   209 , ";  " ,  226 },
 {/*.  238     .*/   239 ,   237 , "ODC" ,    0 },
 {/*.  239     .*/     0 ,   238 , "*  " ,    0 },
 
 {/*.  240     .*/   241 ,    58 , "   " ,  256 },
 {/*.  241     .*/   242 ,   240 , "I  " ,    0 },
 {/*.  242     .*/   243 ,   241 , "N  " ,    0 },
 {/*.  243     .*/   244 ,   242 , "I  " ,    0 },
 {/*.  244     .*/   245 ,   243 , "T  " ,    0 },
 {/*.  245     .*/   246 ,   244 , "(  " ,    0 },
 {/*.  246     .*/   247 ,   245 , "LIT" ,  251 },
 {/*.  247     .*/   248 ,   246 , ")  " ,    0 },
 {/*.  248     .*/   249 ,   247 , ";  " ,    0 },
 {/*.  249     .*/   250 ,   248 , "ODC" ,    0 },
 {/*.  250     .*/     0 ,   249 , "*  " ,    0 },
 
 
 {/*.  251     .*/   252 ,   245 , "RZR" ,    0 },
 {/*.  252     .*/   253 ,   251 , ")  " ,    0 },
 {/*.  253     .*/   254 ,   252 , ";  " ,    0 },
 {/*.  254     .*/   255 ,   253 , "ODC" ,    0 },
 {/*.  255     .*/     0 ,   254 , "*  " ,    0 },
 
 {/*.  256     .*/   257 ,    58 , ";  " ,    0 },
 {/*.  257     .*/   258 ,   256 , "ODC" ,    0 },
 {/*.  258     .*/     0 ,   257 , "*  " ,    0 },
 
 {/*.  259     .*/   260 ,   231 , "RZR" ,    0 },
 {/*.  260     .*/   261 ,   259 , ")  " ,    0 },
 {/*.  261     .*/   262 ,   260 , ";  " ,    0 },
 {/*.  262     .*/   263 ,   261 , "ODC" ,    0 },
 {/*.  263     .*/     0 ,   262 , "*  " ,    0 },
  /*                                               вход с символа - (      */
 {/*.  264     .*/   265 ,     0 , "(  " ,    0 },
 {/*.  265     .*/   266 ,   264 , "AVI" ,    0 },
 {/*.  266     .*/   267 ,   265 , ")  " ,    0 },
 {/*.  267     .*/     0 ,   266 , "AVI" ,    0 },
 {/*.  268     .*/     0 ,   267 , "*  " ,    0 },
 /*                                               вход с символа - =      */
 {/*.  269     .*/   270 ,     0 , "=  " ,    0 },
 {/*.  270     .*/   271 ,   269 , "ZNK" ,    0 },
 {/*.  271     .*/     0 ,   270 , "*  " ,    0 },
 
 {/*.  272     .*/     0 ,   266 , "*  " ,    0 },
 {/*.  273     .*/     0 ,   155 , "*  " ,    0 },
 /*                                                */
 {/*.  274     .*/   159 ,     0 , "IPE" ,    0 },
 
 {/*.  275     .*/   276 ,    96 , "DST" ,    0 }, // пока не надо
 {/*.  276     .*/     0 ,   275 , "*  " ,    0 },
 /*                                               AVI ZNK (      */
 {/*.  277     .*/   278 ,   165 , "(  " ,    0 },
 {/*.  278     .*/   279 ,   277 , "AVI" ,    0 },
 {/*.  279     .*/   280 ,   278 , ")  " ,    0 },
 {/*.  280     .*/   281 ,   279 , "AVI" ,  282 },
 {/*.  281     .*/     0 ,   280 , "*  " ,    0 },
 
 {/*.  282     .*/     0 ,   279 , "*  " ,    0 },
 {/*.  283     .*/   284 ,   179 , "OEN" ,  183 },
 {/*.  284     .*/     0 ,   283 , "*  " ,    0 },
 
 {/*.  285     .*/   286 ,     0 , "OPA" ,    0 }, //вход с OPA
 {/*.  286     .*/   287 ,   285 , "TEL" ,    0 },
 {/*.  287     .*/     0 ,   286 , "*  " ,    0 },
 {/*.  288     .*/   289 ,   153 , "AVI" ,    0 }, 
 {/*.  289     .*/     0 ,   288 , "*  " ,    0 },
 {/*.  290     .*/     0 ,   289 , "*  " ,    0 },
 
 {/*.  291     .*/   292 ,     0 , "OEN" ,    0 }, //вход с OEN
 {/*.  292     .*/   293 ,   291 , "E  " ,    0 },
 {/*.  293     .*/   294 ,   292 , "N  " ,    0 },
 {/*.  294     .*/   295 ,   293 , "D  " ,    0 },
 {/*.  295     .*/   296 ,   294 , "   " ,    0 },
 {/*.  296     .*/   297 ,   295 , "IPR" ,    0 },
 {/*.  297     .*/   298 ,   296 , ";  " ,    0 },
 {/*.  298     .*/   299 ,   297 , "OEN" ,    0 },
 
 {/*.  299     .*/   300 ,   298 , "*  " ,    0 },
 {/*.  300     .*/     0 ,   155 , "*  " ,    0 },

 {/*.  308     .*/     0 ,   153 , "*  " ,    0 },
 
 {/*.  309     .*/     0 ,   164 , "*  " ,    0 },
 
 
 
 
 
 
};

/*
***** Т а б л и ц а  входов в "кусты" ( корней )грамматических правил,
***** содержащая тип ( терминальность или нетерминальность ) корневых
***** символов
*/

struct
 {
  char SYM [4];
  int  VX;
  char TYP;
 } VXOD [ NVXOD ] =
/*   __________ ___________ _____ ______
    |  NN      |    символ | вход| тип  |
    |__________|___________|_____|______|                                  */

{
  {/*.   1     .*/   "AVI" , 164 , 'N' },
  {/*.   2     .*/   "BUK" ,  93 , 'N' },
  {/*.   3     .*/   "CIF" , 136 , 'N' },
  {/*.   4     .*/   "IDE" ,  96 , 'N' },
  {/*.   5     .*/   "IPE" , 153 , 'N' },
  {/*.   6     .*/   "IPR" , 113 , 'N' },
  {/*.   7     .*/   "LIT" , 161 , 'N' },
  {/*.   8     .*/   "MAN" , 143 , 'N' },
  {/*.   9     .*/   "ODC" , 176 , 'N' },
  {/*.  10     .*/   "OEN" , 291 , 'N' },
  {/*.  11     .*/   "OPA" ,   0 , 'N' },
  {/*.  12     .*/   "OPR" , 171 , 'N' },
  {/*.  13     .*/   "PRO" ,   0 , 'N' },
  {/*.  14     .*/   "RZR" , 139 , 'N' },
  {/*.  15     .*/   "TEL" , 179 , 'N' },
  {/*.  16     .*/   "ZNK" ,   0 , 'N' },
  {/*.  17     .*/   "A  " ,  33 , 'T' },
  {/*.  18     .*/   "B  " ,  36 , 'T' },
  {/*.  19     .*/   "C  " ,  39 , 'T' },
  {/*.  20     .*/   "D  " ,  42 , 'T' },
  {/*.  21     .*/   "E  " ,  74 , 'T' },
  {/*.  22     .*/   "M  " ,  84 , 'T' },
  {/*.  23     .*/   "P  " ,  87 , 'T' },
  {/*.  24     .*/   "X  " ,  90 , 'T' },
  {/*.  25     .*/   "0  " ,   1 , 'T' },
  {/*.  26     .*/   "1  " ,   4 , 'T' },
  {/*.  27     .*/   "2  " ,   9 , 'T' },
  {/*.  28     .*/   "3  " ,  12 , 'T' },
  {/*.  29     .*/   "4  " ,  15 , 'T' },
  {/*.  30     .*/   "5  " ,  18 , 'T' },
  {/*.  31     .*/   "6  " ,  21 , 'T' },
  {/*.  32     .*/   "7  " ,  24 , 'T' },
  {/*.  33     .*/   "8  " ,  27 , 'T' },
  {/*.  34     .*/   "9  " ,  30 , 'T' },
  {/*.  35     .*/   "+  " , 107 , 'T' },
  {/*.  36     .*/   "-  " , 110 , 'T' },
  {/*.  37     .*/   ":  " ,   0 , 'T' },
  {/*.  38     .*/   "I  " ,   0 , 'T' },
  {/*.  39     .*/   "R  " ,   0 , 'T' },
  {/*.  40     .*/   "N  " ,   0 , 'T' },
  {/*.  41     .*/   "O  " ,   0 , 'T' },
  {/*.  42     .*/   "T  " ,   0 , 'T' },
  {/*.  43     .*/   "S  " ,   0 , 'T' },
  {/*.  44     .*/   "(  " , 264 , 'T' },
  {/*.  45     .*/   ")  " ,   0 , 'T' },
  {/*.  46     .*/   "   " ,   0 , 'T' },
  {/*.  47     .*/   ";  " ,   0 , 'T' },
  {/*.  48     .*/   "L  " ,   0 , 'T' },
  {/*.  49     .*/   "F  " ,   0 , 'T' },
  {/*.  50     .*/   "=  " , 269 , 'T' },
  {/*.  51     .*/   "H  " ,   0 , 'T' },
  {/*.  52     .*/   "*  " , 198 , 'T' }
};

/*
***** Т а б л и ц а  матрицы смежности - основа построения матрицы
***** преемников
*/

char TPR [ NVXOD ] [ NNETRM ] =
 {
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*AVI*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*BUK*/ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*CIF*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
  {/*IDE*/ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*IPE*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 },
  {/*IPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 },
  {/*LIT*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*MAN*/ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*ODC*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 },
  {/*OEN*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 },
  {/*OPA*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*OPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 },
  {/*PRO*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*RZR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
  {/*TEL*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 },
  {/*ZNK*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  
/*   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  A*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  B*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  C*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  D*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  E*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  M*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  P*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  X*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  0*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  1*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  2*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  3*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  4*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  5*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
  {/*  6*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 },
  {/*  7*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  8*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  9*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  +*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 },
  {/*  -*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 },
  {/*  :*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  I*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  R*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  N*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  O*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  T*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  S*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  (*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  )*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  ;*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*   */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  L*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  F*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  =*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 },
  {/*  H*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
  {/*  **/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 }
/*|_______________________________________________________________________| */
  };
/*..........................................................................*/

void printData(const char * hintText)
{
  if (J >= 0 && I >= 0 && I < 200)
  {
	  printf("analisys symbols %s; %s, next sint is %d\ncel: ", &STROKA[I], hintText, J);
	  for (int i = 0; i < K; i++)
	  {
	  	printf("%s\t%d\t%d\t", CEL[i].CEL1, CEL[i].CEL2, CEL[i].CEL3);
	  }
	  printf("\ndst: ");
	  for (int i = 0; i < L; i++)
	  {
	  	printf("%s\t%d\t%d\t%d\t%d\t", DST[i].DST1, DST[i].DST2, DST[i].DST3, DST[i].DST4, DST[i].DST5);
	  }
	  printf("\n");
	}
}

void print_TRP()
{
	for (int i = 0; i < NVXOD; i++)
	{
		for (int j = 0; j < NNETRM; j++)
		{
			printf("%d\t", TPR[i][j]);
		}
		printf("\n");
	}
}

/*
****** Н А Ч А Л О  обработки исходного текста
*/

/*..........................................................................*/

void compress_ISXTXT()                            /* Программа уплотнения   */
						  /* исходного текста путем */
						  /* удаления "лишних"      */
						  /* пробелов, выполняющая  */
						  /* роль примитивного лек- */
						  /* сического анализатора  */
{
  I3 = 0;
  for ( I1 = 0 ; I1 < NISXTXT ; I1++ )
  {
    for ( I2 = 0 ; I2 < 80 ; I2++ )
    {
     	if ( ISXTXT [ I1 ][ I2 ] != '\0' )
      {
      	if ( ISXTXT [ I1 ][ I2 ] == '\n') ISXTXT [ I1 ][ I2 ] = ' ';
       	if ( ( ISXTXT [ I1 ][ I2 ] == ' ') &&
	   			   ( PREDSYM == ' ' || PREDSYM == ';' ||
	     				 PREDSYM == ')' || PREDSYM == ':' ||
	           	 PREDSYM == '('
	           )
	         )
				{
	 				PREDSYM = ISXTXT [ I1 ][ I2 ];
					continue;
				}

      	if ( ( ISXTXT [ I1 ][ I2 ] == '+' ||
	    			 ISXTXT [ I1 ][ I2 ] == '-' ||
	    			 ISXTXT [ I1 ][ I2 ] == '=' ||
	    			 ISXTXT [ I1 ][ I2 ] == '(' ||
	    			 ISXTXT [ I1 ][ I2 ] == ')' ||
	    			 ISXTXT [ I1 ][ I2 ] == '*'
	           )
	   		 	 && PREDSYM == ' '
	   		 	 )
				{
	 				I3-- ;
	 				goto COMPRESS1;
				}

      	if ( (ISXTXT [ I1 ][ I2 ] == ' ' || ISXTXT [ I1 ][ I2 ] == '\n') &&
	   				 ( PREDSYM == '+' || PREDSYM == '-' ||
	     			 PREDSYM == '=' || PREDSYM == '*'
	   			   )
	  			 )
				{
	 				continue;
				}
COMPRESS1:
       	PREDSYM = ISXTXT [ I1 ][ I2 ];
       	STROKA [ I3 ] = PREDSYM;
       	I3++ ;
       	continue;
      }
     	else
      	break;
    }
  }
  STROKA [I3] = '\x0';
}

/*..........................................................................*/

void build_TPR ()                                 /* Построение таблицы     */
						  /* преемников из матрицы  */
						  /* смежности по алгоритму */
						  /* Варшалла               */
{
  for ( I1 = 0; I1 < NNETRM; I1++ )
  {
    for ( I2 = 0; I2 < NVXOD; I2++ )
    {
      if ( TPR [ I2 ][ I1 ] & ( I1 != I2 ) )
      {
				for ( I3 = 0; I3 < NNETRM; I3++ )
	 				TPR [ I2 ][ I3 ] |= TPR [ I1 ][ I3 ];
      }
    }
  }
}

/*..........................................................................*/

void mcel ( char* T1, int T2, int T3 )            /* программа заполнения   */
 {                                                /* ячейки стека поставлен-*/
						  /* ных целей              */
  strcpy ( CEL [ K ].CEL1, T1 );
  CEL [ K ].CEL2 = T2;
  CEL [ K ].CEL3 = T3;
  K++;
 }

/*..........................................................................*/

void mdst ( char* T1, int T2, int T3, int T4, int T5 )
 {                                                /* программа заполнения   */
  strcpy ( DST [ L ].DST1, T1 );                  /* ячейки стека достигну- */
  DST [ L ].DST2 = T2;                            /* тых целей              */
  DST [ L ].DST3 = T3;
  DST [ L ].DST4 = T4;
  DST [ L ].DST5 = T5;
  L++;
 }


/*..........................................................................*/
						  /* п р о г р а м м а      */
int numb(char* T1, int T2)                     /* вычисления порядкового */
						  /* номера строки в табл.  */
						  /* VXOD, соответствующей  */
						  /* строке-параметру функц.*/
{
  int k;
  for (I1 = 0; I1 < NVXOD; I1++)
  {
    for ( k = 0; k < T2; k++ )
    {
      if ((*(T1+k) != VXOD[I1].SYM[k]))
        goto numb1;
    }
    if ((VXOD[I1].SYM[k] == '\0') ||
        (VXOD[I1].SYM[k] == ' '))
    return I1;
numb1:
    continue;
  }
  return -1;
}

/*..........................................................................*/
						  /*   п р о г р а м м а    */
int sint_ANAL()                                  /*   построения  дерева   */
						  /*синтаксического разбора,*/
{                                                /*выполняющая роль синтак-*/
						  /*сического анализатора   */
  I4 = 0; // max deep of analize
  K = 0;
  L = 0;
  I = 0;
  J = 1;
  mcel ("PRO", I, -1);
  if (!TPR[numb(&STROKA[I], 1)][numb("PRO", 3)])
    return 1;

L2: //inter into graph
  #ifdef _DEBUG_SINT
  	printData("inter graph");
#endif
  J = VXOD[numb(&STROKA[I], 1)].VX;
L3: //check term 1
#ifdef _DEBUG_SINT
  	printData("inter check term 1");
#endif
  J = SINT[J].POSL;
L31: //check term 2
  #ifdef _DEBUG_SINT
  	printData("inter check term 2");
#endif
  I++;
  if (I > I4) I4 = I;
L32:
  #ifdef _DEBUG_SINT
  	printData("before term T");
#endif
  if (VXOD [ numb ( SINT [ J ].DER, 3 ) ].TYP == 'T')
  {  //term resolv
    if ( STROKA [ I ] == SINT [ J ].DER [ 0 ])
      goto L3; //is term, next symbol
    else
      goto L8; //reverse search 1
  }

// block checking end grammar rule
L4:
#ifdef _DEBUG_SINT
  	printData("inter grammar rule check");
#endif
  // grammar rule end check
  if ( SINT [ SINT [ J ].POSL ].DER [ 0 ] == '*' )
  {
    I--;
#ifdef _DEBUG_SINT
    printf("cmp strs: \"%s\" and \"%s\"\n", SINT[J].DER, CEL[K-1].CEL1);
#endif
    if ( strcmp (SINT [J].DER, CEL [K-1].CEL1 ) != 0 )
    {
      if (TPR [numb(SINT[J].DER, 3)][numb (CEL[K-1].CEL1, 3)])
      {
        mdst (SINT[J].DER, CEL[K-1].CEL2, 0, I, J);
        J = VXOD[numb( SINT[J].DER, 3)].VX;
	      goto L3;
      }
      else
      {
        //I++;
        goto L9;
      }
    }
    
    mdst(CEL[K-1].CEL1,CEL[K-1].CEL2,CEL[K-1].CEL3,I,J );
    if (!strcmp(CEL[K-1].CEL1, "PRO")) return 0;
    if (TPR[numb(CEL[K-1].CEL1, 3)][numb(CEL[K-1].CEL1, 3)])
    {
      J = VXOD [ numb ( CEL[K-1].CEL1, 3 ) ].VX ;
      goto L3;
    }
L6:
#ifdef _DEBUG_SINT
  	printData("enter remove ");
#endif
    J = CEL[K-1].CEL3;
    K--; 
    goto L3;
  }
  #ifdef _DEBUG_SINT
  	printData("next symbol is not *");
#endif
  if (!TPR [numb (&STROKA [I], 1)][numb (SINT[J].DER, 3)])
    goto L8; //
  mcel ( SINT[J].DER,I,J );
  
  goto L2;
// end block

// Block checking variants 1
L8: //reverse search 1
  I--;

L9: //reverse search 2
  #ifdef _DEBUG_SINT
  	printData("inter reverse analize 2");
#endif
  if (SINT[J].ALT != 0)
  {
    J = SINT[J].ALT;
    goto L31; //chech term 3
  }

  J = SINT[J].PRED;
#ifdef _DEBUG_SINT
  	printData("check not terminal");
#endif
  if ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
  {
    if ( SINT[J].PRED > 0 )
    {
      mcel (DST[L-1].DST1, DST[L-1].DST2, DST[L-1].DST3);
L10:
#ifdef _DEBUG_SINT
  	  printData("return back DST");
#endif
      J = DST[L-1].DST5;
      L--;
      goto L9;
    }
    if ( SINT[J].PRED == 0 )
    {
      if (!strcmp ( CEL[K-1].CEL1, DST[L-1].DST1 ) )
        goto L6;
      else
        goto L10;
    }
  }
#ifdef _DEBUG_SINT
  	printData("L10 check pred");
#endif
  if ( SINT[J].PRED == 0 )
    goto L9;
  //при выгрузке TEL возвращаемся к месту достижения TEL, если TEL последнее достижение
  if ((strcmp(CEL[K-1].CEL1, "TEL") == 0) && (strcmp(DST[L-1].DST1, "TEL") == 0)) {
    I = DST[L-1].DST4;
    J = CEL[K-1].CEL3;
    K--;
    goto L3;
  }
  J = CEL[K-1].CEL3;
  K--;
#ifdef _DEBUG_SINT
  	printData("continue analize or error");
#endif
  if ( J == -1 )
   return 2;
  else
   goto L8;
 }

/*..........................................................................*/

struct SYM_t                                      /* таблица имен меток и   */
{                                                /* переменных, заполняемая*/
  char NAME [8];                                  /* на первом проходе се-  */
  char TYPE;                                      /* мантического вычисления*/
  char RAZR [5];                                  /* и используемая на вто- */
  char INIT [50];                                 /* ром проходе семантичес-*/
} SYM[NSYM];                                  /* кого вычисления        */

int ISYM = 0;                                     /* текущий индекс таблицы */
						  /* имен                   */

char NFIL [30]="\0";                             /* хранилище имени транс- */
						  /* лируемой программы     */

/*..........................................................................*/

long int BITVALUE(char* s)                        /* п р о г р а м м а      */
{                                                /* перевода двоичной      */
  long int S;                                     /* константы из ASCIIz-ви-*/
                                            /* да во внутреннее пред- */
						  /* ставление типа long int*/
  S = 0;
  while (*s != 'B')
  {
    S <<= 1;
    if (*s == '1')
      S++;
    s++;
  }
  return (S);
}

float BITVALUE_f(char* s)                        /* п р о г р а м м а      */
{                                                /* перевода двоичной      */
  float S;                                     /* константы из ASCIIz-ви-*/
                                            /* да во внутреннее пред- */
              /* ставление типа float*/
  S = 0.f;
  size_t strlen_s = strlen(s);
  size_t point_pos = 0;
  for (; point_pos < strlen_s && s[point_pos] != '.'; point_pos++);
  size_t mantiss_len = point_pos + 1;
  if (mantiss_len < strlen_s)
    for (;mantiss_len < strlen_s && (s[mantiss_len] == '0' || s[mantiss_len] =='1' ); mantiss_len++);
  float current_pow = 1.f;
  for (int i = 1; point_pos >= i || mantiss_len > point_pos + i; i++, current_pow *= 2.f)
  {
    if (point_pos >= i) S += s[point_pos - i] * current_pow;
    if (mantiss_len > point_pos + i) S += s[point_pos + i] * (1 / current_pow);
  }
  if (s[mantiss_len] == 'e')
  {
    // TODO add science float record support???
  }
  return (S);
}

long int DECVALUE(char* s)                        /* п р о г р а м м а      */
{                                                /* перевода двоичной      */
  long int S;                                     /* константы из ASCIIz-ви-*/
                                            /* да во внутреннее пред- */
						  /* ставление типа long int*/
  S = 0;
  while (*s != '\0' ||  *s != ';' || *s != ' ')
  {
    S *= 10;
    S += *s - '0';
    s++;
  }
  return (S);
}

// биты для определения типа

const static uc FIXED_BIT =     0b1;
const static uc FLOAT_BIT =    0b10;
const static uc BIN_BIT =     0b100;
const static uc DEC_BIT =    0b1000;
const static uc LABEL_BIT = 0b10000;
const static uc EQU_BIT =  0b100000;

// структура для разбора объявления

struct ODC_t {
  char varname[10];
  unsigned char type;
  char bits[3];
  char value[35]; // 32 бита, -, B, 0x00
  unsigned char value_type;
} splitted_ODC;

struct dec_rab_var_t {
  const struct SYM_t MRAB;
  int sym_mrab;
  const struct SYM_t MROP;
  int sym_mrop;
} dec_rab_var = {
{"@MRAB", DEC_BIT, "8", "0"},
  -1,
{"@MROP", DEC_BIT, "8", "0"},
  -1
};

void check_mrab_decl()
{
  if (dec_rab_var.sym_mrab == -1)
  {
    memcpy(&(SYM[ISYM]), &dec_rab_var.MRAB, sizeof(struct SYM_t));
    dec_rab_var.sym_mrab = ISYM;
    ISYM++;
  }
}

void check_mrop_decl()
{
  if (dec_rab_var.sym_mrop == -1)
  {
    memcpy(&(SYM[ISYM]), &dec_rab_var.MROP, sizeof(struct SYM_t));
    dec_rab_var.sym_mrop = ISYM;
    ISYM++;
  }
}

/* no mem alloc return dest pointer if success, else NULL */
char * strcpy_next_word(char * dest, size_t dest_size, char * src)
{
  if (dest == NULL || src == NULL) return NULL;
  int i = 0;
  while ((*src < '0' || *src > '9') && // если src начинается не с цифры или буквы
         (*src < 'A' || *src > 'Z') && // ищем букву или цифру
         (*src < 'a' || *src > 'z') && *src != '\0' && *src != ';') src++;
  int strlen_src = strlen(src);
  if (*src == '\0' || *src == ';') return NULL;
  for (; i < dest_size && i <= strlen_src && ((src[i] >= '0' && src[i] <= '9') ||
                                              (src[i] >= 'A' && src[i] <= 'Z') ||
                                              (src[i] >= 'a' && src[i] <= 'z')) ; i++);
  if (i == dest_size) return NULL;
  char tmp = src[i];
  src[i] = '\0';
  strcpy(dest, src);
  src[i] = tmp;
  return dest;
}

int split_ODC()
{
  unsigned char stage = 0;
  int j = DST[I2].DST2;
  unsigned char delims = 0;
  //fprintf(stderr, &(STROKA[j]));
  for (; j <= DST [I2].DST4+1 && stage < 11; j++)
  {
    if (STROKA[j] == ' ' || STROKA[j] == '(' || STROKA[j] == ')' || STROKA[j] == ';')
    {
      if (delims)
        continue;
      else
      {
        stage++;
        delims = 1;
        continue;
      }
    }
    delims = 0;
    switch (stage)
    {
    case 0: // "DCL" skip it
    case 2: // while not end of varname
    case 4: // while not end of type
    case 6: // while not end of subtype
    case 8: // while not end of bits
    case 9: // "init" skip it
      continue;
    case 1: //varname
      if (!strcpy_next_word(splitted_ODC.varname, 10, &(STROKA[j]))) goto parsingError;
      stage++;
      break;
    case 3: // type BIN or DEC
      if (!strcpy_next_word(splitted_ODC.value, 35, &(STROKA[j]))) goto parsingError;
      splitted_ODC.type = 0;
      if (!strcmp(splitted_ODC.value, "BIN")) splitted_ODC.type |= BIN_BIT;
      else if (!strcmp(splitted_ODC.value, "DEC")) splitted_ODC.type |= DEC_BIT;
      else goto typeError;
      stage++;
      break;
    case 5: // subtype FLOAT or FIXED
      if (!strcpy_next_word(splitted_ODC.value, 35, &(STROKA[j]))) goto parsingError;
      if (!strcmp(splitted_ODC.value, "FIXED")) splitted_ODC.type |= FIXED_BIT;
      else if (!strcmp(splitted_ODC.value, "FLOAT")) splitted_ODC.type |= FLOAT_BIT;
      else goto typeError;
      stage++;
      break;
    case 7: // razryad of variable
      splitted_ODC.bits[0] = '\0';
      if (STROKA[j] < '0' || STROKA[j] > '9') // check not number
      {
        j--;
        stage+=2;
        continue;
      }
      int razryad = 0;
      for (; STROKA[j + razryad] >= '0' && STROKA[j + razryad] <= '9'; razryad++);
      if (splitted_ODC.type & BIN_BIT)
      {
        if (razryad > 2) goto razryadOverflow;
        if (razryad == 2) razryad = (STROKA[j++] - '0') * 10;
        razryad += STROKA[j] - '0';
        if (razryad > 31) goto razryadOverflow;
        splitted_ODC.bits[0] = '0' + razryad / 10;
        splitted_ODC.bits[1] = '0' + razryad % 10;
        splitted_ODC.bits[2] = '\0';
      }
      else
      {
        if (razryad > 1 || STROKA[j] > '8') goto razryadOverflow;
        splitted_ODC.bits[0] = STROKA[j];
        splitted_ODC.bits[1] = '\0';
      }
      stage++;
      break;
    case 10:
      if (!strcpy_next_word(splitted_ODC.value, 35, &(STROKA[j]))) goto parsingError;
      splitted_ODC.value_type = 0;
      for (int i = 0; i < strlen(splitted_ODC.value); i++)
      {
        if (splitted_ODC.value[i] == '.') splitted_ODC.value_type |= FLOAT_BIT;
      }
      if ((!splitted_ODC.type) & splitted_ODC.value_type) goto typeMismatch;; // check float init for fixed var
      if (!splitted_ODC.value_type) splitted_ODC.value_type |= FIXED_BIT;
      if (splitted_ODC.value[strlen(splitted_ODC.value) - 1] == 'B') splitted_ODC.value_type |= BIN_BIT;
      else splitted_ODC.value_type |= DEC_BIT;
      stage++;
    }
  }
  if (stage < 11)
  {
    splitted_ODC.value_type = splitted_ODC.type;
    splitted_ODC.value[0] = '0';
    if (splitted_ODC.value_type & BIN_BIT)
    {
      splitted_ODC.value[1] = 'B';
      splitted_ODC.value[2] = '\0';
    }
    else
    {
      splitted_ODC.value[1] = '\0';
    }
  }
  if (splitted_ODC.bits[0] == '\0')
  {
    if (splitted_ODC.type & BIN_BIT)
      strcpy(splitted_ODC.bits, "15");
    else
      strcpy(splitted_ODC.bits, "3");
  }
  return 0;
parsingError:
  STROKA[j + 20] = '\0';
  printf("error parsing in \"%s\"", &(STROKA[j]));
  return -1;
typeError:
  STROKA[j + 20] = '\0';
  printf("bad type \"%s\"", &(STROKA[j]));
  return -2;
razryadOverflow:
  STROKA[j + 20] = '\0';
  printf("error razryad must be less then 33 \"%s\"", &(STROKA[j]));
  return -4;
typeMismatch:
  STROKA[j + 20] = '\0';
  printf("type mismatch - init fixed var with float value \"%s\"", &(STROKA[j]));
  return -5;
}

/*..........................................................................*/
void FORM ()                                      /* п р о г р а м м а      */
{                                                /* представления фрагмента*/
						  /* плотного текста в виде */
						  /* массива 9-ти символьных*/
						  /* лексем                 */
  int i,j;

  for ( IFORMT = 0; IFORMT < MAXFORMT; IFORMT++ )
   memcpy ( FORMT [IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9 );

  IFORMT = 0;
  j = DST [I2].DST2;

FORM1:

  for ( i = j; i <= DST [I2].DST4+1; i++ )
  {
    if (STROKA [i] == ':' || STROKA [i] == ' ' ||
        STROKA [i] == '(' || STROKA [i] == ')' ||
        STROKA [i] == ';' || STROKA [i] == '+' ||
        STROKA [i] == '-' || STROKA [i] == '=' ||
        STROKA [i] == '*')
    {
      FORMT [IFORMT] [i-j] = '\x0';
      IFORMT ++;
      j = i+1;
      goto FORM1;
    }
    else
      FORMT [IFORMT][i-j] = STROKA [i];
  }

  return;
}

unsigned char LAST_OPA_TYPE = 0;
unsigned char LAST_OPA_RAZR[3] = "\0";

/*..........................................................................*/
/* программа рассчёта длины выводимой строки
   в т.ч. при использовании UTF-8*/
int COMM_LENGTH ()
{
  int n_all_symbols = 0;
#ifdef UTF8
  while (n_all_symbols < 50 && COMMENT[n_all_symbols] != '\0')
  {
    if (COMMENT[n_all_symbols] > 0x80) n_all_symbols++;
    n_all_symbols++;
  }
  //if (n_all_symbols == ) return
  return n_all_symbols;
#else
  n_all_symbols = strlen(COMMENT);
  if (n_all_symbols > 51)
  {
    return 51;
  } else {
    return n_all_symbols;
  }
#endif
}
						  /* п р о г р а м м а      */
void ZKARD ()                                     /* записи очередной сгене-*/
 {                                                /* рированной записи вы-  */
						  /* ходного файла в массив */
						  /* ASSTXT                 */
  char i;
  //copy comment
  memcpy(ASS_CARD._BUFCARD.COMM, COMMENT, COMM_LENGTH());
  memcpy ( ASSTXT [ IASSTXT++ ],
			   ASS_CARD.BUFCARD, 80 );

  for ( i = 0; i < 79; i++ )
    ASS_CARD.BUFCARD [i] = ' ';
  ASS_CARD.BUFCARD [79] = '\n';
  return;
 }

/*..........................................................................*/
						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала AVI на пер-*/
						  /* вом проходе.   Здесь   */
						  /* AVI -   "арифм.выраж." */
int AVI1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала BUK на пер-*/
						  /* вом проходе.   Здесь   */
						  /* BUK -   "буква"        */
int BUK1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала CIF на пер-*/
						  /* вом проходе.   Здесь   */
						  /* CIF -   "цифра"        */
int CIF1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IDE на пер-*/
						  /* вом проходе.   Здесь   */
						  /* IDE -   "идентификатор"*/
int IDE1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IPE на пер-*/
						  /* вом проходе.   Здесь   */
						  /* IPE - "имя переменной" */
int IPE1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IPR на пер-*/
						  /* вом проходе.   Здесь   */
						  /* IPR -   "имя программы" */
int IPR1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала LIT на пер-*/
						  /* вом проходе.   Здесь   */
						  /* LIT -   "литерал"      */
int LIT1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала MAN на пер-*/
						  /* вом проходе.   Здесь   */
						  /* MAN -   "мантисса"     */
int MAN1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала ODC на пер-*/
						  /* вом проходе.   Здесь   */
						  /* ODC - "операт.ПЛ1- DCL"*/
int ODC1 ()
 {
  int i;
  int split_result = split_ODC(); /* форматирование ПЛ1-оператора DCL */
  if (split_result) return split_result;

  for ( i = 0; i < ISYM; i++ )                    /* если фиксируем повтор- */
   {                                              /* повторное объявление   */
    if (!strcmp(SYM[i].NAME, splitted_ODC.varname) &&  /* второго терма оператора*/
    strlen(SYM[i].NAME) ==              /* DCL, то                */
           strlen(splitted_ODC.varname)
       )
     return 6;                                    /* завершение программы   */
						  /* по ошибке              */
   }

  strcpy(SYM[ISYM].NAME, splitted_ODC.varname);          /* при отсутствии повтор- */
  strcpy(SYM[ISYM].RAZR, splitted_ODC.bits);          /* ного объявления иденти-*/
						  /* фикатора запоминаем его*/
						  /* вместе с разрядностью в*/
						  /* табл.SYM               */
  SYM[ISYM].TYPE = splitted_ODC.type;                        /* устанавливаем тип   */
  if (splitted_ODC.value_type & DEC_BIT)
    strcpy(SYM [ISYM].INIT,  splitted_ODC.value);
  else
  {
    if (splitted_ODC.value_type & FIXED_BIT)
      sprintf(SYM[ISYM].INIT, "%ld", BITVALUE(splitted_ODC.value));
    else
      sprintf(SYM[ISYM].INIT, "%f", BITVALUE_f(splitted_ODC.value));
  }
  ISYM++;
  return 0;   /* успешное завешение     */
						  /* программы              */
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OEN на пер-*/
						  /* вом проходе.   Здесь   */
						  /* OEN - "операт.ПЛ1-END" */
int OEN1 ()
 {
  char i = 0;
  FORM();                                        /* форматирование ПЛ1-опе-*/
						  /* ратора END             */
  for (i = 0; i < ISYM; i++)                    /* если вторй терм опера- */
						  /* тора END записан в табл*/
  {                                              /* SYM и его тип = "P",то:*/
    if (!strcmp(SYM[i].NAME, FORMT [1]) &&
        (SYM[i].TYPE == LABEL_BIT) &&
        strlen(SYM [i].NAME) ==
          strlen(FORMT[1]))
     return 0;               /* успешное завершение программы               */
  }
  return 1;                  /* иначе завершение программы по ошибке        */
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OPA на пер-*/
						  /* вом проходе.   Здесь   */
						  /* OPA - "операт.присваи- */
						  /* вания арифметический   */
int OPA1 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OPR на пер-*/
						  /* вом проходе.   Здесь   */
						  /* OPR - "операт.ПЛ1-PROC"*/
int OPR1 ()
{
  FORM ();                                 /* форматируем оператор ПЛ1 PROC */
  strcpy ( SYM [ISYM].NAME, FORMT [0] );          /* перепишем имя ПЛ1-прог-*/
                                                  /* раммы в табл. SYM,     */
  SYM [ISYM].TYPE   = LABEL_BIT;        /* установим тип этого имени LABEL  */
  SYM [ISYM++].RAZR [0] = '\x0';          /* установим разрядность равной 0 */
  // add base EQU register names
  strcpy(SYM[ISYM].NAME, "@RBAS");
  SYM[ISYM].TYPE = EQU_BIT;
  SYM[ISYM].RAZR[0] = '\0';
  strcpy(SYM[ISYM++].INIT, "12");
  strcpy(SYM[ISYM].NAME, "@RVIX");
  SYM[ISYM].TYPE = EQU_BIT;
  SYM[ISYM].RAZR[0] = '\0';
  strcpy(SYM[ISYM++].INIT, "14");
  strcpy(SYM[ISYM].NAME, "@RRAB");
  SYM[ISYM].TYPE = EQU_BIT;
  SYM[ISYM].RAZR[0] = '\0';
  strcpy(SYM[ISYM++].INIT, "2");
  return 0;                                /* успешное завершение программы */
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала PRO на пер-*/
						  /* вом проходе.   Здесь   */
						  /* PRO - "программа"      */

int PRO1 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала RZR на пер-*/
						  /* вом проходе.   Здесь   */
						  /* RZR - "разрядность"    */

int RZR1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала TEL на пер-*/
						  /* вом проходе.   Здесь   */
						  /* TEL - "тело программы" */

int TEL1 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала ZNK на пер-*/
						  /* вом проходе.   Здесь   */
						  /* ZNK - "знак операции"  */

int ZNK1 ()
 {
  return 0;
 }
 
/*..........................................................................*/


/*..........................................................................*/

int check_sym_exists(char * candidate)
{
  for (int i = 0; i < ISYM; i++)
  {
    if (!strcmp(SYM[i].NAME, candidate)) return i;
  }
  return -1;
}

int is_bools_declared = 0;
void declare_bools()
{
  if (is_bools_declared) return;
  strcpy(SYM[ISYM].NAME, "@TRUE");
  strcpy(SYM[ISYM].RAZR, "1");
  strcpy(SYM[ISYM].INIT, "1");
  SYM[ISYM++].TYPE = BIN_BIT | FIXED_BIT;
  strcpy(SYM[ISYM].NAME, "@FALS");
  strcpy(SYM[ISYM].RAZR, "1");
  strcpy(SYM[ISYM].INIT, "0");
  SYM[ISYM++].TYPE = BIN_BIT | FIXED_BIT;
  is_bools_declared = 1;
}

int rrop_exists = 0;
void check_rrop()
{
  if (rrop_exists) return;
  strcpy(SYM[ISYM].NAME, "@RROP");
  SYM[ISYM].TYPE = EQU_BIT;
  SYM[ISYM].RAZR[0] = '\0';
  strcpy(SYM[ISYM++].INIT, "3");
}

// return 0 if priority of right op is not greater, else return 1
int check_priority(int begin)
{
  int i = begin;
  // go this operation
  for (; STROKA[i] != '\0' && STROKA[i] != '*' && STROKA[i] != '/' && STROKA[i] != ';' &&
         STROKA[i] != ')' && STROKA[i] != '+' && STROKA[i] != '-' && STROKA[i] != '='; i++);
  if (STROKA[i] == ')' || STROKA[i] == ';' || STROKA[i] == '\0') return 0;
  if (STROKA[i + 1] == '(') return 1;
  if (STROKA[i] == '*' || STROKA[i] == '/') return 0;
  // check second operation or end
  i++;
  for (; STROKA[i] != '\0' && STROKA[i] != '*' && STROKA[i] != '/' && STROKA[i] != ';' &&
         STROKA[i] != ')' && STROKA[i] != '+' && STROKA[i] != '-'; i++);
  if (STROKA[i] == ')' || STROKA[i] == '+' || STROKA[i] == '-' ||
      STROKA[i] == '\0' || STROKA[i] == ';') return 0;
  return 1;
}

int next_not_letter_or_number(int begin)
{
  int i = begin;
  for (;(STROKA[i] >= '0' && STROKA[i] <= '9') ||
        (STROKA[i] >= 'a' && STROKA[i] <= 'z') ||
        (STROKA[i] >= 'A' && STROKA[i] <= 'Z'); i++);
  return i;
}

int next_operand(int current_operand)
{
  int i = current_operand;
  for (;(STROKA[i] >= '0' && STROKA[i] <= '9') || // go to end this operand
        (STROKA[i] >= 'a' && STROKA[i] <= 'z') ||
        (STROKA[i] >= 'A' && STROKA[i] <= 'Z'); i++);
  // while not next or not end of AVI
  while (STROKA[i] != '\0' && STROKA[i] != ';' && ((STROKA[i] < '0' || STROKA[i] > '9') &&
                                                   (STROKA[i] < 'a' || STROKA[i] > 'z') &&
                                                   (STROKA[i] < 'A' || STROKA[i] > 'Z'))
         && STROKA[i] != '(') i++;
  return i;
}

void conv_from_dec_fixed_to_bin_fixed(struct SYM_t var, char * reg)
{
  check_mrab_decl();
  //MVC @MRAB+n(m),var
  memcpy(ASS_CARD._BUFCARD.OPERAC, "MVC", 3);
  strcpy(ASS_CARD._BUFCARD.OPERAND, "@MRAB");//+5(3),B
  if (SYM[dec_rab_var.sym_mrab].RAZR[0] != '8')
  {
    char str[50];
    char fmt[] = "+%c(%c)";
    sprintf(str, fmt, '0' + '8' - SYM[dec_rab_var.sym_mrab].RAZR[0],
      SYM[dec_rab_var.sym_mrab].RAZR[0]);
    strcat(ASS_CARD._BUFCARD.OPERAND, str);
  }
  strcat(ASS_CARD._BUFCARD.OPERAND, ",");
  strcat(ASS_CARD._BUFCARD.OPERAND, var.NAME);
  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
  COMMENT = "Загрузка dec в память со смещением";
  ZKARD();
  // CVB  reg,@MRAB
  memcpy(ASS_CARD._BUFCARD.OPERAC, "CVB", 3);
  strcpy(ASS_CARD._BUFCARD.OPERAND, reg);
  strcat(ASS_CARD._BUFCARD.OPERAND, ",@MRAB");
  COMMENT = "преобр из dec в bin c загрузкой в reg";
  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
  ZKARD();
}

int subAVI(int begin, uc expected_type, const char * expected_razr)
{
  int curpos = begin;
  uc left_operand_is_single_term = 1;
  if (STROKA[curpos] != '(')
  {
    STROKA[curpos + 20] = '\0';
    fprintf(stderr, "bad subAVI begin, expected \'(\', founded \"%s\"", STROKA[curpos]);
    return -8;
  }
  curpos++;
  int NOSH = 0;
parse_avi:
  if (check_priority(curpos))
  {
    if (left_operand_is_single_term)
    {
      left_operand_is_single_term = 0;
      char left_operand[6] = "\0";
      if (!strcpy_next_word(left_operand, 6, &STROKA[curpos]))
      {
        STROKA[curpos + 20] = '\0';
        fprintf(stderr, "parse operand error \"%s\"", &(STROKA[curpos]));
        return -6;
      }
      for (int i = 0; i < ISYM; i++)     /* ищем этот терм в таблице имён */
      {
        if (!strcmp(SYM[i].NAME, left_operand))
        {
          // result of subexpr stored in @RRVAL, if expected_type is bin fixed or in
          // in memory @MOPD if FIXED DEC
          int next_pos = subAVI(next_operand(curpos), expected_type, expected_razr);
          // load left operand
          if ((expected_type & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT)) /* в случае типа bin fixed*/
          {
            if ((SYM[i].TYPE & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT))
            {
              /* формируем код ассемблеровской операции LOAD */
              int is_half = strcmp(SYM[i].RAZR, "15") <= 0;
              ASS_CARD._BUFCARD.OPERAC[0] = 'L';
              /* а при разрядности > 15 формируем код ассемблера */
              if (is_half)         /* разрядность <= 15    */
                ASS_CARD._BUFCARD.OPERAC[1] = 'H';
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              /* формируем первый и второй операнды ассемблеровской операции */
              ASS_CARD._BUFCARD.OPERAND[strlen    /* вставляем разделитель  */
                (ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка переменной в регистр";
              ZKARD();
            }
            else //type mismatch
            {
              conv_from_dec_fixed_to_bin_fixed(SYM[i], "@RRAB");
            }
            int next_symbol = next_not_letter_or_number(curpos);
            // useless
            if (next_pos == next_symbol)
              return 0;
            switch(STROKA[next_symbol])
            {
              case '+':
              {
                ASS_CARD._BUFCARD.OPERAC[0] = 'A';
                COMMENT = "сложение";
                break;
              }
              case '-':
              {
                ASS_CARD._BUFCARD.OPERAC[0] = 'S';
                COMMENT = "вычитание";
                break;
              }
              case '*':
              {
                ASS_CARD._BUFCARD.OPERAC[0] = 'M';
                COMMENT = "умножение";
                break;
              }
              case '/':
              {
                ASS_CARD._BUFCARD.OPERAC[0] = 'D';
                COMMENT = "деление";
                break;
              }
              case '=':
              {
                char load[3] = "LH";
                declare_bools();
                //CR
                memcpy(ASS_CARD._BUFCARD.OPERAC, "CR", 2);
                strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,@RROP");
                ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                ZKARD();
                //BC
                memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
                strcpy(ASS_CARD._BUFCARD.OPERAND, "8,*+6");
                ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                ZKARD();
                //LH                  @RRAB,@FALS
                memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
                strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,@FALS");
                ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                ZKARD();
                //BC                  15,*+4
                memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
                strcpy(ASS_CARD._BUFCARD.OPERAND, "15,*+4");
                ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                ZKARD();
                //LH                  @RRAB.@TRUE
                memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
                strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB.@TRUE");
                ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                ZKARD();

                // TODO support next bool AVI processing
                return 0;
              }
            }
            ASS_CARD._BUFCARD.OPERAC[1] = 'R'; // 2 reg operation
            strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,@RROP");
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            ZKARD();
          }
          else if ((expected_type & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
          {
            // TODO conv from dec to bin
            memcpy(ASS_CARD._BUFCARD.OPERAC, "MVC", 3);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "@MRAB");//+5(3),B
            if (SYM[dec_rab_var.sym_mrab].RAZR[0] != '8')
            {
              char str[50];
              char fmt[] = "+%c(%c)";
              sprintf(str, fmt, '0' + '8' - SYM[dec_rab_var.sym_mrab].RAZR[0],
                SYM[dec_rab_var.sym_mrab].RAZR[0]);
              strcat(ASS_CARD._BUFCARD.OPERAND, str);
            }
            strcat(ASS_CARD._BUFCARD.OPERAND, ",");
            strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
            // заменяем конец строки пробелом
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "Загрузка FIX DEC в @DRAB";
            memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
              COMMENT, COMM_LENGTH());
            ZKARD();
            int next_symbol = next_not_letter_or_number(curpos);
            // useless
            LAST_OPA_TYPE = DEC_BIT | FIXED_BIT;
            strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
            if (next_pos == next_symbol)
              return 0;
            // TODO: decimal ariphmetic op processing
          }
          curpos = next_pos;
          goto parse_avi;
        }
      }
      fprintf(stderr, "variable not found \"%s\"");
    }
    else
    {
      fprintf(stderr, "for parsing such ariphmetic expression need realize stack for saving left operand");
    }
  }
  else
  {
    if (left_operand_is_single_term) // single term left op
    {
      left_operand_is_single_term = 0;
      char left_operand[6] = "\0";
      if (!strcpy_next_word(left_operand, 6, &STROKA[curpos]))
      {
        STROKA[curpos + 20] = '\0';
        fprintf(stderr, "parse operand error \"%s\"", &(STROKA[curpos]));
        return -6;
      }
      for (int i = 0; i < ISYM; i++)     /* ищем этот терм в таблице имён */
      {
        if (!strcmp(SYM[i].NAME, left_operand))
        {
          // load left operand
          if ((expected_type & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT)) /* в случае типа bin fixed*/
          {
            if ((SYM[i].TYPE & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT))
            {
              /* формируем код ассемблеровской операции LOAD */
              int is_half = strcmp(SYM[i].RAZR, "15") <= 0;
              ASS_CARD._BUFCARD.OPERAC[0] = 'L';
              /* а при разрядности > 15 формируем код ассемблера */
              if (is_half)         /* разрядность <= 15    */
                ASS_CARD._BUFCARD.OPERAC[1] = 'H';
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              /* формируем первый и второй операнды ассемблеровской операции */
              ASS_CARD._BUFCARD.OPERAND[strlen    /* вставляем разделитель  */
                (ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка переменной в регистр";
              memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                COMMENT, COMM_LENGTH());
              ZKARD();
            }
            else //type mismatch
            {
              conv_from_dec_fixed_to_bin_fixed(SYM[i], "@RRAB");
            }
            curpos = next_not_letter_or_number(curpos);
            if (STROKA[curpos] == ';')
              return 0;
          }
          else if ((SYM[i].TYPE & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
          {
            if (dec_rab_var.sym_mrab == -1)
            {
              memcpy(&(SYM[ISYM]), &dec_rab_var.MRAB, sizeof(struct SYM_t));
              dec_rab_var.sym_mrab = ISYM;
              ISYM++;
            }
            memcpy(ASS_CARD._BUFCARD.OPERAC, "MVC", 3);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "@DRAB");//+5(3),B
            if (SYM[dec_rab_var.sym_mrab].RAZR[0] != '8')
            {
              char str[50];
              char fmt[] = "+%c(%c)";
              sprintf(str, fmt, '0' + '8' - SYM[dec_rab_var.sym_mrab].RAZR[0],
                SYM[dec_rab_var.sym_mrab].RAZR[0]);
              strcat(ASS_CARD._BUFCARD.OPERAND, str);
            }
            strcat(ASS_CARD._BUFCARD.OPERAND, ",");
            strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
            // заменяем конец строки пробелом
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "Загрузка FIX DEC в @DRAB";
            memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
              COMMENT, COMM_LENGTH());
            ZKARD();
            curpos = next_not_letter_or_number(curpos);
            // useless
            LAST_OPA_TYPE = DEC_BIT | FIXED_BIT;
            strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
            if (STROKA[curpos] == ';')
              return 0;
          }
          break;
        }
      }
    }
    curpos = next_not_letter_or_number(curpos);
    if (curpos == ';')
      return 0;
    char right_op[8] = "\0";
    int with_conversation = 0;
    strcpy_next_word(right_op, 8, &(STROKA[curpos]));
    int right_index = check_sym_exists(right_op);
    if (right_index == -1)
    {
      STROKA[curpos + 20] = '\0';
      fprintf(stderr, "next variable not declared \"%s\"", &(STROKA[curpos]));
      return -7;
    }
    if (SYM[right_index].TYPE != expected_type)
    {
      with_conversation = 1;
      // TODO conversation
    }
    if (expected_type == (BIN_BIT | FIXED_BIT))
    {
      switch(STROKA[curpos])
      {
        case '+':
        {
          ASS_CARD._BUFCARD.OPERAC[0] = 'A';
          COMMENT = "сложение";
          break;
        }
        case '-':
        {
          ASS_CARD._BUFCARD.OPERAC[0] = 'S';
          COMMENT = "вычитание";
          break;
        }
        case '*':
        {
          ASS_CARD._BUFCARD.OPERAC[0] = 'M';
          COMMENT = "умножение";
          break;
        }
        case '/':
        {
          ASS_CARD._BUFCARD.OPERAC[0] = 'D';
          COMMENT = "деление";
          break;
        }
        case '=':
        {
          char load[3] = "LH";
          declare_bools();
          //CR
          if (strcmp(LAST_OPA_RAZR, "15") <= 0)
            memcpy(ASS_CARD._BUFCARD.OPERAC, "CH", 3);
          else
            memcpy(ASS_CARD._BUFCARD.OPERAC, "C", 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,");
          if (with_conversation)
            strcat(ASS_CARD._BUFCARD.OPERAND, "RROP");
          else
            strcat(ASS_CARD._BUFCARD.OPERAND, right_op);
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          ZKARD();
          //BC
          memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND, "8,*+6");
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          ZKARD();
          //LH                  @RRAB,@FALS
          memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,@FALS");
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          ZKARD();
          //BC                  15,*+4
          memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND, "15,*+4");
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          ZKARD();
          //LH                  @RRAB.@TRUE
          memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
          strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB.@TRUE");
          ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
          LAST_OPA_TYPE = BIN_BIT | FIXED_BIT;
          ZKARD();
          // TODO support next bool AVI processing
          return 0;
        }
      }
      if (with_conversation)
        ASS_CARD._BUFCARD.OPERAC[1] = 'R'; // 2 reg operation
      else if (strcmp(LAST_OPA_RAZR, "15") <= 0)
        ASS_CARD._BUFCARD.OPERAC[1] = 'H'; // h operation
      strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,");
      if (with_conversation)
        strcat(ASS_CARD._BUFCARD.OPERAND, "@RROP");
      else
        strcat(ASS_CARD._BUFCARD.OPERAND, right_op);
      ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
      ZKARD();
    }
    else if ((expected_type & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
    {
      // TODO DECIMAL OPERATION PROCESSING
    }
  }
  if (expected_type & BIN_BIT)
  {
    check_rrop();
    memcpy(ASS_CARD._BUFCARD.OPERAC, "LR", 2);
    strcpy(ASS_CARD._BUFCARD.OPERAND, "@RROP,@RRAB");
    COMMENT = "перемещение результата RR";
    ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
    ZKARD();
  }
  else if (expected_type & DEC_BIT)
  {
    // TODO copying dec from MRAB to MROP
  }
  return curpos;
}

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
      /* нетерминала AVI на втором проходе. Здесь */
              /* AVI -   "арифм.выраж." */
int AVI2 ()
{
  char i;
  // проверяем, что данное AVI часть OPA := IPE=AVI;
  if (!strcmp(DST[I2+1].DST1, "OPA"))
  {
    uc left_operand_is_single_term = 1;
    int curpos = DST[I2].DST2;
    int NOSH = 0;
parse_high_level_avi:
    if (check_priority(curpos))
    {
      if (left_operand_is_single_term)
      {
        left_operand_is_single_term = 0;
        char left_operand[6] = "\0";
        if (!strcpy_next_word(left_operand, 6, &STROKA[curpos]))
        {
          STROKA[curpos + 20] = '\0';
          fprintf(stderr, "parse operand error \"%s\"", &(STROKA[curpos]));
          return -6;
        }
        for (i = 0; i < ISYM; i++)     /* ищем этот терм в таблице имён */
        {
          if (!strcmp(SYM[i].NAME, left_operand))
          {
            // result of subexpr stored in @RRVAL, if expected_type is bin fixed or in
            // in memory @MOPD if FIXED DEC
            int next_pos = subAVI(next_operand(curpos), SYM[i].TYPE, SYM[i].RAZR);
            // load left operand
            if ((SYM[i].TYPE & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT)) /* в случае типа bin fixed*/
            {
              /* формируем код ассемблеровской операции LOAD */
              int is_half = strcmp(SYM[i].RAZR, "15") <= 0;
              ASS_CARD._BUFCARD.OPERAC[0] = 'L';
              /* а при разрядности > 15 формируем код ассемблера */
              if (is_half)         /* разрядность <= 15    */
                ASS_CARD._BUFCARD.OPERAC[1] = 'H';
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              /* формируем первый и второй операнды ассемблеровской операции */
              ASS_CARD._BUFCARD.OPERAND[strlen    /* вставляем разделитель  */
                (ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка переменной в регистр";
              memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                COMMENT, COMM_LENGTH());
              ZKARD();
              int next_symbol = next_not_letter_or_number(curpos);
              // useless
              LAST_OPA_TYPE = BIN_BIT | FIXED_BIT;
              strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
              if (next_pos == next_symbol)
                return 0;
              switch(STROKA[next_symbol])
              {
                case '+':
                {
                  ASS_CARD._BUFCARD.OPERAC[0] = 'A';
                  COMMENT = "сложение";
                  break;
                }
                case '-':
                {
                  ASS_CARD._BUFCARD.OPERAC[0] = 'S';
                  COMMENT = "вычитание";
                  break;
                }
                case '*':
                {
                  ASS_CARD._BUFCARD.OPERAC[0] = 'M';
                  COMMENT = "умножение";
                  break;
                }
                case '/':
                {
                  ASS_CARD._BUFCARD.OPERAC[0] = 'D';
                  COMMENT = "деление";
                  break;
                }
                case '=':
                {
                  char load[3] = "LH";
                  declare_bools();
                  //CR
                  memcpy(ASS_CARD._BUFCARD.OPERAC, "CR", 2);
                  strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,@RROP");
                  COMMENT = "сравнение знач в reg";
                  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                  ZKARD();
                  //BC
                  memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
                  strcpy(ASS_CARD._BUFCARD.OPERAND, "8,*+6");
                  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                  COMMENT = "if eq goto load true";
                  ZKARD();
                  //LH                  @RRAB,@FALS
                  memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
                  strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,@FALS");
                  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                  COMMENT = "load false";
                  ZKARD();
                  //BC                  15,*+4
                  memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
                  strcpy(ASS_CARD._BUFCARD.OPERAND, "15,*+4");
                  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                  COMMENT = "goto end of equal operator";
                  ZKARD();
                  //LH                  @RRAB.@TRUE
                  memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
                  strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB.@TRUE");
                  ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
                  COMMENT = "load true";
                  ZKARD();
                  LAST_OPA_TYPE = BIN_BIT | FIXED_BIT;
                  // TODO support next bool AVI processing
                  return 0;
                }
              }
              ASS_CARD._BUFCARD.OPERAC[1] = 'R'; // 2 reg operationsr
              strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,@RROP");
              ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
              ZKARD();
            }
            else if ((SYM[i].TYPE & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
            {
              if (dec_rab_var.sym_mrab == -1)
              {
                memcpy(&(SYM[ISYM]), &dec_rab_var.MRAB, sizeof(struct SYM_t));
                dec_rab_var.sym_mrab = ISYM;
                ISYM++;
              }
              memcpy(ASS_CARD._BUFCARD.OPERAC, "MVC", 3);
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@DRAB");//+5(3),B
              if (SYM[dec_rab_var.sym_mrab].RAZR[0] != '8')
              {
                char str[50];
                char fmt[] = "+%c(%c)";
                sprintf(str, fmt, '0' + '8' - SYM[dec_rab_var.sym_mrab].RAZR[0],
                  SYM[dec_rab_var.sym_mrab].RAZR[0]);
                strcat(ASS_CARD._BUFCARD.OPERAND, str);
              }
              strcat(ASS_CARD._BUFCARD.OPERAND, ",");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              // заменяем конец строки пробелом
              ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка FIX DEC в @DRAB";
              memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                COMMENT, COMM_LENGTH());
              ZKARD();
              int next_symbol = next_not_letter_or_number(curpos);
              // useless
              LAST_OPA_TYPE = DEC_BIT | FIXED_BIT;
              strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
              if (next_pos == next_symbol)
                return 0;
              // TODO: decimal ariphmetic op processing
            }
            curpos = next_pos;
            goto parse_high_level_avi;
          }
        }
        fprintf(stderr, "variable not found \"%s\"");
      }
      else
      {
        fprintf(stderr, "for parsing such ariphmetic expression need realize stack for saving left operand");
      }
    }
    else
    {
      if (left_operand_is_single_term) // single term left op
      {
        left_operand_is_single_term = 0;
        char left_operand[6] = "\0";
        if (!strcpy_next_word(left_operand, 6, &STROKA[curpos]))
        {
          STROKA[curpos + 20] = '\0';
          fprintf(stderr, "parse operand error \"%s\"", &(STROKA[curpos]));
          return -6;
        }
        for (i = 0; i < ISYM; i++)     /* ищем этот терм в таблице имён */
        {
          if (!strcmp(SYM[i].NAME, left_operand))
          {
            // result of subexpr stored in @RRVAL, if expected_type is bin fixed or in
            // in memory @MOPD if FIXED DEC
            // load left operand
            if ((SYM[i].TYPE & (BIN_BIT | FIXED_BIT)) == (BIN_BIT | FIXED_BIT)) /* в случае типа bin fixed*/
            {
              /* формируем код ассемблеровской операции LOAD */
              int is_half = strcmp(SYM[i].RAZR, "15") <= 0;
              ASS_CARD._BUFCARD.OPERAC[0] = 'L';
              /* а при разрядности > 15 формируем код ассемблера */
              if (is_half)         /* разрядность <= 15    */
                ASS_CARD._BUFCARD.OPERAC[1] = 'H';
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              /* формируем первый и второй операнды ассемблеровской операции */
              ASS_CARD._BUFCARD.OPERAND[strlen    /* вставляем разделитель  */
                (ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка переменной в регистр";
              ZKARD();
              curpos = next_not_letter_or_number(curpos);
              // useless
              LAST_OPA_TYPE = BIN_BIT | FIXED_BIT;
              strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
              if (STROKA[curpos] == ';')
                return 0;
            }
            else if ((SYM[i].TYPE & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
            {
              if (dec_rab_var.sym_mrab == -1)
              {
                memcpy(&(SYM[ISYM]), &dec_rab_var.MRAB, sizeof(struct SYM_t));
                dec_rab_var.sym_mrab = ISYM;
                ISYM++;
              }
              memcpy(ASS_CARD._BUFCARD.OPERAC, "MVC", 3);
              strcpy(ASS_CARD._BUFCARD.OPERAND, "@DRAB");//+5(3),B
              if (SYM[dec_rab_var.sym_mrab].RAZR[0] != '8')
              {
                char str[50];
                char fmt[] = "+%c(%c)";
                sprintf(str, fmt, '0' + '8' - SYM[dec_rab_var.sym_mrab].RAZR[0],
                  SYM[dec_rab_var.sym_mrab].RAZR[0]);
                strcat(ASS_CARD._BUFCARD.OPERAND, str);
              }
              strcat(ASS_CARD._BUFCARD.OPERAND, ",");
              strcat(ASS_CARD._BUFCARD.OPERAND, left_operand);
              // заменяем конец строки пробелом
              ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
              COMMENT = "Загрузка FIX DEC в @DRAB";
              memcpy(ASS_CARD._BUFCARD.COMM,      /* и построчный коментарий*/
                COMMENT, COMM_LENGTH());
              ZKARD();
              curpos = next_not_letter_or_number(curpos);
              // useless
              LAST_OPA_TYPE = DEC_BIT | FIXED_BIT;
              strcpy(LAST_OPA_RAZR, SYM[i].RAZR);
              if (STROKA[curpos] == ';')
                return 0;
            }
            break;
          }
        }
      }
      curpos = next_not_letter_or_number(curpos);
      if (curpos == ';')
        return 0;
      char right_op[8] = "\0";
      int with_conversation = 0;
      strcpy_next_word(right_op, 8, &(STROKA[curpos]));
      int right_index = check_sym_exists(right_op);
      if (right_index == -1)
      {
        STROKA[curpos + 20] = '\0';
        fprintf(stderr, "next variable not declared \"%s\"", &(STROKA[curpos]));
        return -7;
      }
      if (SYM[right_index].TYPE != SYM[i].TYPE)
      {
        with_conversation = 1;
        // TODO conversation
      }
      if (LAST_OPA_TYPE == (BIN_BIT | FIXED_BIT))
      {
        switch(STROKA[curpos])
        {
          case '+':
          {
            ASS_CARD._BUFCARD.OPERAC[0] = 'A';
            COMMENT = "сложение";
            break;
          }
          case '-':
          {
            ASS_CARD._BUFCARD.OPERAC[0] = 'S';
            COMMENT = "вычитание";
            break;
          }
          case '*':
          {
            ASS_CARD._BUFCARD.OPERAC[0] = 'M';
            COMMENT = "умножение";
            break;
          }
          case '/':
          {
            ASS_CARD._BUFCARD.OPERAC[0] = 'D';
            COMMENT = "деление";
            break;
          }
          case '=':
          {
            char load[3] = "LH";
            declare_bools();
            //CR
            if (strcmp(LAST_OPA_RAZR, "15") <= 0)
              memcpy(ASS_CARD._BUFCARD.OPERAC, "CH", 3);
            else
              memcpy(ASS_CARD._BUFCARD.OPERAC, "C", 2);
            strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,");
            if (with_conversation)
              strcat(ASS_CARD._BUFCARD.OPERAND, "RROP");
            else
              strcat(ASS_CARD._BUFCARD.OPERAND, right_op);
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "Сравнение чисел";
            ZKARD();
            //BC
            memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "8,*+6");
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "goto load TRUE if equals";
            ZKARD();
            //LH                  @RRAB,@FALS
            memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB,@FALS");
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "load false to result";
            ZKARD();
            //BC                  15,*+4
            memcpy(ASS_CARD._BUFCARD.OPERAC, "BC", 2);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "15,*+4");
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            COMMENT = "goto store result";
            ZKARD();
            //LH                  @RRAB.@TRUE
            memcpy(ASS_CARD._BUFCARD.OPERAC, load, 2);
            strcpy(ASS_CARD._BUFCARD.OPERAND, "@RRAB.@TRUE");
            ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
            LAST_OPA_TYPE = BIN_BIT | FIXED_BIT;
            COMMENT = "load TRUE to result";
            ZKARD();
            // TODO support next bool AVI processing
            return 0;
          }
        }
        if (with_conversation)
          ASS_CARD._BUFCARD.OPERAC[1] = 'R'; // 2 reg operation
        else if (strcmp(LAST_OPA_RAZR, "15") <= 0)
          ASS_CARD._BUFCARD.OPERAC[1] = 'H'; // h operation
        strcpy(ASS_CARD._BUFCARD.OPERAND,"@RRAB,");
        if (with_conversation)
          strcat(ASS_CARD._BUFCARD.OPERAND, "@RROP");
        else
          strcat(ASS_CARD._BUFCARD.OPERAND, right_op);
        ASS_CARD._BUFCARD.OPERAND[strlen(ASS_CARD._BUFCARD.OPERAND)] = ' ';
        //COMMENT = "swap registers";
        ZKARD();
      }
      else if ((SYM[i].TYPE & (DEC_BIT | FIXED_BIT)) == (DEC_BIT | FIXED_BIT)) /* в случае типа DEC fixed*/
      {
        // TODO DECIMAL OPERATION PROCESSING
      }
      curpos++;
      curpos = next_not_letter_or_number(curpos);
      if (STROKA[curpos] == ';') return 0;
      goto parse_high_level_avi;
    }
  }
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала BUK на вто-*/
						  /* ром проходе.   Здесь   */
						  /* BUK -   "буква"        */

int BUK2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала CIF на вто-*/
						  /* ром проходе.   Здесь   */
						  /* CIF -   "цифра"        */

int CIF2 ()
{
  return 0;
}

/*..........................................................................*/


						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IDE на вто-*/
						  /* ром проходе.   Здесь   */
						  /* IDE -   "идентификатор"*/

int IDE2 ()
{
  return 0;
}


/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IPE на вто-*/
						  /* ром проходе.   Здесь   */
						  /* IPE - "имя переменной" */

int IPE2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала IPR на вто-*/
						  /* ром проходе.   Здесь   */
						  /* IPR -   "имя программы" */

int IPR2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала LIT на вто-*/
						  /* ром проходе.   Здесь   */
						  /* LIT -   "литерал"      */

int LIT2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала MAN на вто-*/
						  /* ром проходе.   Здесь   */
						  /* MAN -   "мантисса"     */

int MAN2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала ODC на вто-*/
						  /* ром проходе.   Здесь   */
						  /* ODC - "операт.ПЛ1- DCL"*/

int ODC2 ()
{
  return 0;
}

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OEN на вто-*/
						  /* ром проходе.   Здесь   */
						  /* OEN - "операт.ПЛ1-END" */

						  /* программа    формирует */
						  /* эпилог ассемблеровского*/
						  /* эквивалента ПЛ1-прог-  */
						  /* раммы                  */
int OEN2()
{
  char RAB[20];
  char i = 0;
  FORM();                                        /* форматируем ПЛ1-опера- */
						  /* тор END                */

  memcpy(ASS_CARD._BUFCARD.OPERAC, "BCR", 3);  /* формируем код безуслов-*/
						  /*ного возврата управления*/
						  /* в вызывающую программу */

  memcpy(ASS_CARD._BUFCARD.OPERAND,"15,@RVIX", 8);/* операнды команды и     */

  COMMENT = "Выход из программы";
  ZKARD();                                       /* запомнить опреацию     */
						  /* Ассемблера             */
						  /* далее идет блок форми- */
						  /* рования декларативных  */
						  /* псевдоопераций DC для  */
						  /* каждого идентификатора,*/
						  /* попавшего в табл.SYM   */
  for ( i = 0; i < ISYM; i++ )
  {                                              /* если строка табл.SYM   */
    if (SYM[i].TYPE & (BIN_BIT | DEC_BIT))                  /* если это переменная */
    {
      if (!strcmp(SYM[i].NAME, "@MRAB") || !strcmp(SYM[i].NAME, "@MROP"))
      {
         /* выравнивание */
        memcpy(ASS_CARD._BUFCARD.OPERAC, "DS", 2);
        memcpy(ASS_CARD._BUFCARD.OPERAND, "0F", 2);
        COMMENT = "выравнивание";
        ZKARD();
      }
      strcpy(ASS_CARD._BUFCARD.METKA,         /* пишем идентификатор в  */
      SYM[i].NAME);                     /* поле метки псевдооперации DC */
      ASS_CARD._BUFCARD.METKA[strlen
        (ASS_CARD._BUFCARD.METKA)] = ' '; /* пишем разделитель полей*/
      memcpy(ASS_CARD._BUFCARD.OPERAC,   //пишем код псевдооператора для выделения памяти под переменную */
             "DC", 2 );
      if (SYM[i].TYPE & BIN_BIT) // если двоичное
      {
        if (strcmp(SYM[i].RAZR, "15") <= 0) /* формируем операнды псевдооперации DC         */
          strcpy(ASS_CARD._BUFCARD.OPERAND,      /* для случая полуслова   */ "H\'");
        else                                      /* или                    */
          strcpy(ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */ "F\'" );
      }
      else if (SYM[i].TYPE & DEC_BIT)
      {
        strcpy(ASS_CARD._BUFCARD.OPERAND, "PL3\'");     // стандартная длина десятичной переменной
        if (strcmp(SYM[i].RAZR, "0")) ASS_CARD._BUFCARD.OPERAND[2] = SYM[i].RAZR[0]; // если указана пользователем
      }
      strcat(ASS_CARD._BUFCARD.OPERAND, SYM[i].INIT);
      ASS_CARD._BUFCARD.OPERAND[strlen        /* замыкающий апостроф    */
        (ASS_CARD._BUFCARD.OPERAND)] = '\'';  /*          и             */
      COMMENT = "Определение переменной";
      ZKARD();                                 /* запомнить операцию     */
						  /*    Ассемблера          */
    }
  }
      /* далее идет блок декларативных ассемблеровс- */
      /* ких EQU-операторов, определяющих регистры */
  for (i = 0; i < ISYM; i++)
  {
    if (SYM[i].TYPE & EQU_BIT)
    {
      memcpy(ASS_CARD._BUFCARD.METKA, SYM[i].NAME, strlen(SYM[i].NAME)); /* формирование EQU-псев- */
      memcpy(ASS_CARD._BUFCARD.OPERAC, "EQU", 3);   /* дооперации */
      COMMENT = "DEFINE register";
      memcpy(ASS_CARD._BUFCARD.OPERAND, SYM[i].INIT, strlen(SYM[i].INIT));
      ZKARD();
    }
  }
  memcpy(ASS_CARD._BUFCARD.OPERAC, "END", 3);  /* формирование кода ас-  */
						  /* семблеровской псевдо-  */
						  /* операции END,          */
  i = 0;
  //while ( FORMT [1][i] != '\x0' )                 /* ее операнда            */
  //  ASS_CARD._BUFCARD.OPERAND [i] = FORMT[1][i++];/*         и              */
	COMMENT = "Конец программы";

  ZKARD ();         /* запоминание псевдооперации */
  return 0;             /* завершение программы   */
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OPA на вто-*/
						  /* ром проходе.   Здесь   */
						  /* OPA - "операт.присваи- */
						  /* вания арифметический   */

int OPA2 ()
{
  int i;

  //FORM ();                                        /*форматируем ПЛ1-оператор*/
						  /*присваивания арифметич. */

  char var_name[10] = "\0";
  strcpy_next_word(var_name, 10, &STROKA[DST[I2].DST2]);

  for ( i = 0; i < ISYM; i++ )
  {
    if (!strcmp(SYM[i].NAME, var_name)) // if exists
    {
      if (SYM[i].TYPE & BIN_BIT)              /* если этот идентификатор*/
      {                                      /* имеет тип bin,то:*/

        if (strcmp(SYM[i].RAZR, "15" )    /* если bin fixed (15),то:*/
					    <= 0 )
          memcpy(ASS_CARD._BUFCARD.OPERAC,   /* сформировать команду   */
               "STH", 3);/* записи полуслова       */

        else                                  /* иначе:                 */
          memcpy(ASS_CARD._BUFCARD.OPERAC,   /* команду записи слова   */
            "ST", 2);

      strcpy(ASS_CARD._BUFCARD.OPERAND,   /*       доформировать    */
          "@RRAB,");/*          операнды      */

      strcat(ASS_CARD._BUFCARD.OPERAND,   /*           команды      */
              var_name) ;

      ASS_CARD._BUFCARD.OPERAND[strlen    /*              и         */
      (ASS_CARD._BUFCARD.OPERAND)] = ' ';
      COMMENT = "Форм знач арифм.выражения";
      ZKARD();                             /* запомнить операцию     */
						  /* Ассемблера  и          */
	    return 0;                             /* завершить программу    */
	   }

	  else                                    /* если идентификатор не  */
						  /* имеет тип bin fixed,то:*/
	   return 3;                              /* завершение с диагности-*/
						  /* кой ошибки             */
       }
   }
  return 4;                                       /* если идентификатор ра- */
						  /* нее не определен через */
						  /* ПЛ1-оператор DCL,то за-*/
						  /* вершение с диагностикой*/
						  /* ошибки                 */
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала OPR на вто-*/
						  /* ром проходе.   Здесь   */
						  /* OPR - "операт.ПЛ1-PROC"*/

						  /* программа    формирует */
						  /* пролог ассемблеровского*/
						  /* эквивалента  исходной  */
						  /* ПЛ1-программы          */
int OPR2 ()
 {
  char i = 0;
  FORM();                                        /* форматируем оператор   */
						  /* ПЛ1 - "начало процедур-*/
              /* ного блока"            */
  ASS_CARD.BUFCARD[79] = '\n';
  while (FORMT[0][i] != '\x0')
   ASS_CARD._BUFCARD.METKA[i++] = FORMT[0][i];  /* нулевой терм используем*/
						  /* как метку в START-псев-*/
						  /* дооперации Ассемблера  */

  memcpy(ASS_CARD._BUFCARD.OPERAC, "START", 5);/* достраиваем код и опе- */
  memcpy(ASS_CARD._BUFCARD.OPERAND, "0", 1);   /* ранды  в  START-псевдо-*/
  COMMENT = "Начало программы";
  ZKARD();                                       /* запоминаем карту Ассем-*/
						  /* блера                  */

  memcpy(ASS_CARD._BUFCARD.OPERAC, "BALR", 4); /* формируем BALR-операцию*/
  memcpy(ASS_CARD._BUFCARD.OPERAND,             /* Ассемблера             */
          "@RBAS,0", 7 );
  COMMENT = "Загрузить регистр базы";
  ZKARD();                                       /* и запоминаем ее        */

  memcpy(ASS_CARD._BUFCARD.OPERAC, "USING", 5);/* формируем USING-псевдо-*/
  memcpy(ASS_CARD._BUFCARD.OPERAND,             /* операцию Ассемблера    */
           "*,@RBAS", 7);
  COMMENT = "Назначить регистр базой";
  ZKARD();                                       /* и запоминаем ее        */

  return 0;                                       /* завершить подпрограмму */
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала PRO на вто-*/
						  /* ром проходе.   Здесь   */
						  /* PRO - "программа"      */

int PRO2 ()                                       /*прогр.формирует выходной*/
 {                                                /*файл                    */

  FILE *fp;                                       /*набор                   */
						  /*рабочих                 */
						  /*переменных              */

  strcat ( NFIL , "ass" );                        /*сформировать имя выход- */
						  /*ного файла              */

  if ( (fp = fopen ( NFIL , "wb" )) == NULL )     /*при неудачн.открыт.ф-ла */
   return (7);                                    /* сообщение об ошибке    */

  else                                            /*иначе:                  */
   fwrite (ASSTXT, 80 , IASSTXT , fp);            /* формируем тело об.файла*/
  fclose ( fp );                                  /*закрываем об'ектный файл*/
  return ( 0 );                                   /*завершить полдпрограмму */
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала RZR на вто-*/
						  /* ром проходе.   Здесь   */
						  /* RZR - "разрядность"    */

int RZR2 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала TEL на вто-*/
						  /* ром проходе.   Здесь   */
						  /* TEL - "тело программы" */

int TEL2 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /* п р о г р а м м а      */
						  /* семантич. вычисления   */
						  /* нетерминала ZNK на вто-*/
						  /* ром проходе.   Здесь   */
						  /* ZNK - "знак операции"  */

int ZNK2 ()
 {
  return 0;
 }

/*..........................................................................*/

						  /*  п р о г р а м м а     */
						  /* управления абстрактной */
						  /* ЭВМ  -  семантического */
						  /* вычислителя, интерпре- */
						  /* тирующего абстрактную  */
						  /* программу, сформирован-*/
						  /* ную синтаксическим ана-*/
						  /* лизатором в стеке дос- */
						  /* тигнутых целей.        */

						  /* Суть алгоритма управле-*/
						  /*ния  в  последовательной*/
int gen_COD()                                    /*интерпретации строк сте-*/
{                                                /*ка достижений  в направ-*/
  int NOSH;                                       /*лении от дна к вершине. */

  int (*FUN[NNETRM][2])() =                    /*При этом каждая строка  */
   {                                              /*воспринимается как кома-*/
     {/*    1  */    AVI1, AVI2 },                /*нда абстрактной ЭВМ со  */
     {/*    2  */    BUK1, BUK2 },                /*следующими полями:      */
     {/*    3  */    CIF1, CIF2 },
     {/*    4  */    IDE1, IDE2 },		  /* - DST.DST1 - код опера-*/
     {/*    5  */    IPE1, IPE2 },      	  /*ции;                    */
     {/*    6  */    IPR1, IPR2 },
     {/*    7  */    LIT1, LIT2 },            	  /* - DST.DST2 - левая гра-*/
     {/*    8  */    MAN1, MAN2 },		  /*ница интерпретируемого  */
     {/*    9  */    ODC1, ODC2 },		  /*фрагмента исх.текста;   */
     {/*   10  */    OEN1, OEN2 },
     {/*   11  */    OPA1, OPA2 },		  /* - DST.DST4 -правая гра-*/
     {/*   12  */    OPR1, OPR2 },		  /*ница интерпретируемого  */
     {/*   13  */    PRO1, PRO2 },		  /*фрагмента исх.текста.   */
     {/*   14  */    RZR1, RZR2 },
     {/*   15  */    TEL1, TEL2 },
     {/*   16  */    ZNK1, ZNK2 }
   };

  for (I2 = 0; I2 < L; I2++)                    /* организация первого    */
    if ((NOSH = FUN[numb(DST[I2].DST1, 3)][0]()) != 0)
                                  /* прохода семантического вычисления */
      return (NOSH);              /* выход из программы по ошибке */

  for (I2 = 0; I2 < L; I2++)                    /* организация второго    */
    if ((NOSH = FUN[numb(DST[I2].DST1, 3)][1]()) != 0)
                                  /* прохода семантического вычисления */
      return (NOSH);              /* выход из программы по ошибке      */
  return 0;                       /* успешное завершение программы     */
}

/*..........................................................................*/

              /*  п р о г р а м м а,     */
              /* организующая последова- */
              /* тельную обработку исходного текста: */
              /* - лексич.анализатором;  */
              /* - синтаксич.анализат.;  */
              /* - семантич.вычислителем */
int main (int argc, char **argv)
{                                                /* рабочие переменные:    */
  FILE *fp;                                       /* - указатель на файл;   */
  
						  /*проверяем корректность  */
						  /*командной строки        */
  if ( argc != 2 )
  {                                              /* по ошибке в командн.стр*/
    printf ("%s\n", "Ошибка в командной строке"); /* выдать диагностику и   */
    return 6;                                       /* завершить трансляцию   */
  }
  char *ptr=argv[1];                              /* - указатель на первый  */
						  /*параметр командной стр. */

  strcpy ( NFIL, ptr );                           /*изъять имя транслируемой*/
						  /*программы из командной  */
						  /*строки в рабочее поле   */
  
						  /* проверка типа исх.файла*/
  if
   (
    strcmp ( &NFIL [ strlen ( NFIL )-3 ], "pli" ) /* если тип не "pli", то: */
   )
	{
    printf ( "%s\n",                              /* выдать диагностику и   */
     "Неверный тип файла с исходным текстом" );
    return 5;                                       /* завершить трансляцию   */
  }
  else                                            /* если тип файла "pli",то*/
	{                                              /*пытаемся открыть файл и */
    if ( (fp = fopen ( NFIL , "rb" )) == NULL )   /*при неудачн.открыт.ф-ла */
						  /* сообщение об ошибке и  */
    {
      printf ( "%s\n",
       "Не найден файл с исходным текстом" );
      return 4;                                     /* завершение трансляции  */
    }
		else                                          /* иначе:                 */
						  /* пишем файл в массив    */
						  /*  ISXTXT                */
    {
      for ( NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++ )
      {
				if ( !fread ( ISXTXT [NISXTXT], 1, 80, fp ) )
				{
	  			if ( feof ( fp ) )                      /* в конце файла идем на  */
	  				goto main1;                            /* метку  main1           */
	  			else                                    /* при сбое чтения        */
	   			{                                      /* выдаем диагностику     */
	    			printf ( "%s\n",
	     							 "Ошибка при чтении фыйла с исх.текстом" );
	    			return 3;                               /* и завершаем трансляцию */
	   			}
	 			}
      }
      printf ( "%s\n",                            /*при пеерполнении массива*/
       "Переполнение буфера чтения исх.текста" ); /* ISXTXT выдать диагн.   */
      return 1;                                     /* и завершить трансляцию */
    }
  }

main1:                                            /* по завершении чтения   */
						  /* исх.файла формируем    */
  fclose(fp);                                 /* префикс имени выходного*/
  printf("readed %d block from input file\n", NISXTXT);
#ifdef _DEBUG_SINT
  fprintf(stderr, "SINT 288 is %s\n", SINT[288].DER);
#endif
  NFIL[strlen(NFIL) - 3] = '\0';            /* Ассемблеровского файла */

  memset(ASS_CARD.BUFCARD, ' ', 80);           /* чистка буфера строки   */
						  /* выходного ассемблеров- */
						  /* ского файла            */

  compress_ISXTXT();                             /* лексический анализ     */
						  /* исходного текста       */

  build_TPR();                                   /* построение матрицы     */
						  /* преемников             */
						  #ifdef _DEBUG_SINT
	print_TRP();
	#endif
  if (sint_ANAL ())                           /* синтаксический анализ  */
  {                                              /* исходного текста       */
    STROKA [I4 +20] = '\x0';
    fprintf                                       /* если найдены ошибки    */
    ( stderr,                                           /* синтаксиса, то :       */
       "%s%s%s%s\n",
       "ошибка синтаксиса в исх.тексте -> ",      /* выдаем диагностику и   */
       "\"...", &STROKA[I4], "...\""
    );
    fprintf
    (stderr,
       "%s\n", "трансляция прервана"
    );
    return 2;                                      /* завершаем трансляцию   */
  }
  else                                            /* иначе делаем           */
  {
    printf("sint analysys finished\n");
    switch ( gen_COD () )                         /* семантическое вычислен.*/
     {
      case  0:                                    /*если код завершения = 0,*/
						  /* то:                    */

       printf ( "%s\n",                           /* - диагностич.сообщение;*/
	"трансляция завершена успешно" );
       return 0;                                    /* - завершить трансляцию */


      case  1:                                    /*если код завершения = 1,*/
						  /* то:                    */
       printf ( "%s\n",                           /* - диагностич.сообщение;*/
	"несовпадение имени процедуры в прологе-эпилоге" );
       break;                                     /* - выйти на обобщающую  *//* - диагностич.сообщение;*/
						  /*диагностику             */

      case  2:                                    /*если код завершения = 2,*/
						  /* то:                    */
       STROKA [ DST [I2].DST2 +20 ] = '\x0';      /* - диагностич.сообщение;*/
       printf ( "%s%s\n%s%s%s\n",
	"недопустимый тип идентификатора: ",
	 &FORMT [1], " в исх.тексте -> \"...",
	  &STROKA [ DST [I2].DST2 ], "...\"" );
       break;                                     /* - выйти на обобщающую  */
						  /*диагностику             */

      case  3:                                    /*если код завершения = 3,*/
						  /* то:                    */
       STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
       printf ( "%s%s\n%s%s%s\n",
	"недопустимый тип идентификатора: ",
	  &FORMT [IFORMT-1], " в исх.тексте -> \"...",
	   &STROKA [ DST [I2].DST2 ], "...\"" );
       break;                                     /* -выйти на обобщающую   */
						  /*диагностику             */

      case  4:                                    /*если код завершения = 4,*/
						  /* то:                    */
       STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
       printf ( "%s%s\n%s%s%s\n",
	"неопределенный идентификатор: ",
	 &FORMT [IFORMT-1], " в исх.тексте -> \"...",
	  &STROKA [ DST [I2].DST2 ], "...\"" );
       break;                                     /* - выйти на обобщающую  */
						  /*диагностику             */

      case  5:                                    /*если код завершения = 5,*/
						  /* то:                    */
       STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
       printf ( "%s%c\n%s%s%s\n",
	"недопустимая операция: ",
	 STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ],
	 " в исх.тексте -> \"...", &STROKA [ DST [I2].DST2 ], "...\"");
       break;                                     /* - выйти на обобщающую  */
						  /*диагностику             */

      case  6:                                    /*если код завершения = 6 */
						  /* то:                    */
       STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
       printf ( "%s%s\n%s%s%s\n",
	"повторное объявление идентификатора: ",
	 &FORMT [1], " в исх.тексте -> \"...",
	  &STROKA [ DST [I2].DST2 ], "...\"" );
       break;                                     /* - выйти на обобщающую  */
						  /*диагностику             */

     }

   }

  fprintf (stderr, "%s\n", "трансляция прервана" );       /* обобщающая диагностика */
	
  return 0;
 }
/*..........................................................................*/
